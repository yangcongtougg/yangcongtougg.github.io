<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-loading-bar.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "adec0fae"
    });
  daovoice('update');
  </script>














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico?v=5.1.3">






  <meta name="keywords" content="python面试题," />





  <link rel="alternate" href="/atom.xml" title="洋葱头gg's Blog" type="application/atom+xml" />






<meta name="description" content="Python面试题 关键在于了解Python的语言特性，结合具体的例子来理解Python的语言特性  python的函数参数传递看两个例子： 12345a = 1def fun(a):  a = 2fun(a)print a  # 1 12345a = []def fun(a):  a.append(1)fun(a)print a  # [1] 所有的变量都可以理解是内存中一个对象的“引用”，或者">
<meta name="keywords" content="python面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="最新python面试题之python特性">
<meta property="og:url" content="http://yoursite.com/2018/01/05/最新python面试题之python特性/index.html">
<meta property="og:site_name" content="洋葱头gg&#39;s Blog">
<meta property="og:description" content="Python面试题 关键在于了解Python的语言特性，结合具体的例子来理解Python的语言特性  python的函数参数传递看两个例子： 12345a = 1def fun(a):  a = 2fun(a)print a  # 1 12345a = []def fun(a):  a.append(1)fun(a)print a  # [1] 所有的变量都可以理解是内存中一个对象的“引用”，或者">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-22T10:17:48.087Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="最新python面试题之python特性">
<meta name="twitter:description" content="Python面试题 关键在于了解Python的语言特性，结合具体的例子来理解Python的语言特性  python的函数参数传递看两个例子： 12345a = 1def fun(a):  a = 2fun(a)print a  # 1 12345a = []def fun(a):  a.append(1)fun(a)print a  # [1] 所有的变量都可以理解是内存中一个对象的“引用”，或者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/05/最新python面试题之python特性/"/>





  <title>最新python面试题之python特性 | 洋葱头gg's Blog</title>
  








</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/yangcongtougg" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">洋葱头gg's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/05/最新python面试题之python特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="洋葱头gg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/max.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洋葱头gg's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">最新python面试题之python特性</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T13:15:25+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试题/" itemprop="url" rel="index">
                    <span itemprop="name">面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Python面试题"><a href="#Python面试题" class="headerlink" title="Python面试题"></a>Python面试题</h2><blockquote>
<p>关键在于了解Python的语言特性，结合具体的例子来理解Python的语言特性</p>
</blockquote>
<h4 id="python的函数参数传递"><a href="#python的函数参数传递" class="headerlink" title="python的函数参数传递"></a>python的函数参数传递</h4><p>看两个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">  a = 2</span><br><span class="line">fun(a)</span><br><span class="line">print a  # 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">def fun(a):</span><br><span class="line">  a.append(1)</span><br><span class="line">fun(a)</span><br><span class="line">print a  # [1]</span><br></pre></td></tr></table></figure>
<p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看成是类似于c中void*的感觉。<br>上面的例子我们通过<code>id</code>来查看引用<code>a</code>的地址，来进行比较理解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">  print &quot;func_in&quot;,id(a)   # func_in 41322472</span><br><span class="line">  a = 2</span><br><span class="line">  print &quot;re-point&quot;,id(a), id(2)   # re-point 41322448 41322448</span><br><span class="line">print &quot;func_out&quot;,id(a), id(1)  # func_out 41322472 41322472</span><br><span class="line">fun(a)</span><br><span class="line">print a  # 1</span><br></pre></td></tr></table></figure></p>
<p>注：具体的id的值在不同的电脑上运行时可能有所不同，并且在Python中对较小的数字都进行了缓存。<br>可以看到，在执行完<code>a = 2</code>之后，a引用中保存的值，及内存地址发生了变化，由原来的<code>1</code>对象的地址变成了<code>2</code>这个实体对象的内存地址。<br>而在第2个例子<code>a</code>引用保存的内存地址就不会发生变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">def fun(a):</span><br><span class="line">  print &quot;func_in&quot;,id(a)  # func_in 53629256</span><br><span class="line">  a.append(1)</span><br><span class="line">print &quot;func_out&quot;,id(a)     # func_out 53629256</span><br><span class="line">fun(a)</span><br><span class="line">print a  # [1]</span><br></pre></td></tr></table></figure></p>
<p>在这里需要记住的是类型是属于对象的，而不是变量的。而对象有两种，“可更改”（mutable）和“不可更改的对象”（imnutable）。在Python中，string，tuples和numbers是不可更改的对象，而list，dict，set等则是可以修改的对象。（这就是这个问题的重点）</p>
<p>当一个引用传递给函数的时候，函数自动的复制一份引用，这个函数里的引用和外边的引用就没有半毛钱的关系了。所以第一个例子里函数把引用指向了一个不可变的对象，当函数返回的时候，外面的引用没半毛钱的感觉，而第二个例子不一样，函数内部引用指向的是可变对象，对它的操作就和定位了指针地址一样，在内存里直接的进行修改。</p>
<p>如果还不明白的话，这里有更好的解释： <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="noopener">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<hr>
<h4 id="Python中的元类"><a href="#Python中的元类" class="headerlink" title="Python中的元类"></a>Python中的元类</h4><p>这个就非常的不常用了，但是像在ORM这种复杂的结构中还是会需要的，详情请看：:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<hr>
<h4 id="staticmethod和-classmethod"><a href="#staticmethod和-classmethod" class="headerlink" title="@ staticmethod和@ classmethod"></a>@ staticmethod和@ classmethod</h4><p>Python中其实有3个方法，及静态方法（staticmethod），类方法（classmethod）和实例方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">  print&quot;executing foo(%s)&quot; % (x)</span><br><span class="line">class A(object):</span><br><span class="line">  def foo(self, x):</span><br><span class="line">    print(&quot;executing foo(%s,%s)&quot; % (self, x))</span><br><span class="line">  @classmethod</span><br><span class="line">  def class_foo(cls, x):</span><br><span class="line">    print(&quot;executing class_foo(%s,%s)&quot; % (cls, x))</span><br><span class="line">  @staticmethod</span><br><span class="line">  def static_foo(x):</span><br><span class="line">    print(&quot;executing static_foo(%s)&quot; % x)</span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure></p>
<p>这里先理解下函数参数里的self和cls。这个self和cls是对类或者实例的绑定，对于一般的函数来说我们可以这么的调用<code>foo(x)</code>，这个就是最常用的函数，它的工作跟任何的东西（类，实例）无关。对于实例方法，我们知道在类里每次定义方法的时候都需要绑定这个实例，就是<code>foo(self,x)</code>，为什么要这么做呢？因为实例方法的调用离不开实例，我们需要把实例自己传递给函数，调用的时候是这样的<code>a.foo(x)</code>（其实是<code>foo(a,x)</code>）。类方法一样，只不过它传递的是类而不是实例，<code>A.class_foo(x)</code>。注意这里的self和cls可以替换成别的参数，但是Python中的约定是这俩，还是不要改的好。<br>对于静态方法其实和普通的方法一样，不需要对谁进行绑定，唯一的区别就是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来进行调用。<br>下面是一张表格，来比对各种方法的可以的调用形式</p>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">实例方法</th>
<th style="text-align:center">类方法</th>
<th style="text-align:center">静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a = A()</td>
<td style="text-align:center">a.foo(x)</td>
<td style="text-align:center">a.class_foo(x)</td>
<td style="text-align:center">a.static_foo(x)</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">A.class_foo(x)</td>
<td style="text-align:center">A.static_foo(x)</td>
</tr>
</tbody>
</table>
<p>更度多的关于这个问题：<br>1.<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a><br>2.<a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></p>
<hr>
<h4 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h4><h5 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h5><blockquote>
<p>是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance就是类变量，用于跟踪存在着多少个Test的实例。</p>
</blockquote>
<h5 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h5><blockquote>
<p>实例化之后，每个实例单独拥有的变量</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">  um_of_instance = 0</span><br><span class="line">  def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line">    Test.num_of_instance += 1</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print est.num_of_instance  # 0</span><br><span class="line">    t1 = Test(&apos;jack&apos;)</span><br><span class="line">    print est.num_of_instance  # 1</span><br><span class="line">    t2 = Test(&apos;lucy&apos;)</span><br><span class="line">    print t1.name, t1.num_of_instance  # jack 2</span><br><span class="line">    print t2.name.num_of_instance  # lucy 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充的例子</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">  name=&quot;aaa&quot;</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=&quot;bbb&quot;</span><br><span class="line">print p1.name  # bbb</span><br><span class="line">print p2.name  # aaa</span><br><span class="line">print Person.name  # aaa</span><br></pre></td></tr></table></figure>
<p>这里的<code>p1.name=&#39;bbb&#39;</code>是实例调用了类变量，这其实和上面的第一个问题一样，就是函数传参的问题，<code>p1.name</code>一开始是指向的类变量<code>name=&#39;aaa&#39;</code>，但是在实例的作用域里把类变量的引用改变了，就变成了一个实例变量，self.name不再引用Person的类变量name了。<br>可以看看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">  name=[]</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(1)</span><br><span class="line">print p1.name  # [1]</span><br><span class="line">print p2.name  # [1]</span><br><span class="line">print Person.name  # [1]</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>
<hr>
<h4 id="Python的自省"><a href="#Python的自省" class="headerlink" title="Python的自省"></a>Python的自省</h4><p>这个也是Python彪悍的特性。<br>自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单一句就是运行时能够捕获到对象的类型。比如type()，dir()（返回当前模块的属性列表)，getattr(返回对象的属性)，setattr()（动态添加属性）这两者参考set，get方法，hasattr()（判断是否包含哪个属性），isinstance()（判断对象是否属于哪个类型）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = &#123;&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3&#125;</span><br><span class="line">c = True</span><br><span class="line">print type(a),type(b),type(c) # &lt;type &apos;list&apos;&gt; &lt;type &apos;dict&apos;&gt; &lt;type &apos;bool&apos;&gt;</span><br><span class="line">print isinstance(a,list)  # True</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p>可能你见过列表推导式，却没有见过字典推导式，在2.7中才加入的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key: value for (key, value) in iterable&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Python中单下划线和双下划线"><a href="#Python中单下划线和双下划线" class="headerlink" title="Python中单下划线和双下划线"></a>Python中单下划线和双下划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyClass():</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...             self.__superprivate = &quot;Hello&quot;</span><br><span class="line">...             self._semiprivate = &quot;, world!&quot;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; mc = MyClass()</span><br><span class="line">&gt;&gt;&gt; print mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute &apos;__superprivate&apos;</span><br><span class="line">&gt;&gt;&gt; print mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line">&gt;&gt;&gt; print mc.__dict__</span><br><span class="line">&#123;&apos;_MyClass__superprivate&apos;: &apos;Hello&apos;, &apos;_semiprivate&apos;: &apos;, world!&apos;&#125;</span><br></pre></td></tr></table></figure>
<p><code>__foo__</code>：一种约定，Python内部的名字，用来区别其他用户自定义的命名，以防冲突么就是例如：<code>__init__(),__del__(),__calll__()</code>这些的特殊的方法。<br><code>_foo</code>：一种约定，用来指定变量私有，程序员用来指定私有变量的一种方式，不能用<code>from module impore*</code>导入，其他的方面和公有一样访问。<br><code>__foo</code>：这个有真正的意义：解析器用<code>_classname__foo</code>来代替这个名字，以区别和其他类相同的命名，它无法直接像公有成员一样随便访问，通过<code>对象名._类名__xxx</code>这样的方式访问。<br>详情见：<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a><br>或者：<a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p>
<hr>
<h4 id="字符串格式化：-和-format"><a href="#字符串格式化：-和-format" class="headerlink" title="字符串格式化：%和.format"></a>字符串格式化：%和.format</h4><p>.format在许多发面看起来会更加的便利，对于%最烦人的是它无法同时传递一个变量和元组。你可能会想下面的代码不会有什么问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % name</span><br></pre></td></tr></table></figure></p>
<p>但是，如果name恰好是(1,2,3)，那么它将会跑出一个TypeError异常，为了保证它是正常的，你必须这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></table></figure></p>
<p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.<br>你为什么不用它？</p>
<ul>
<li>不知道它（在读这个之前）</li>
<li>为了和Python2.5兼容（譬如logging库建议使用<code>%</code>）</li>
</ul>
<p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="noopener">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p>
<hr>
<h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a><br>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a><br>这里有个关于生成器的创建问题面试官有考： 问： 将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x*x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x*x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</p>
<hr>
<h4 id="args-and-kwargs"><a href="#args-and-kwargs" class="headerlink" title="*args and **kwargs"></a>*args and **kwargs</h4><p>用*args和*<em>kwargs只是为了方便并没有强制使用它们。<br>当你不确定你的函数里将要传递多少参数时你可以用*</em>args.例如,它可以传递任意数量的参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_everything(*args):</span><br><span class="line">        for count, thing in enumerate(args):</span><br><span class="line">...         print &apos;&#123;0&#125;. &#123;1&#125;&apos;.format(count, thing)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;)</span><br><span class="line">0. apple</span><br><span class="line">1. banana</span><br><span class="line">2. cabbage</span><br></pre></td></tr></table></figure></p>
<p>相似的,**kwargs允许你使用没有事先定义的参数名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def table_things(**kwargs):</span><br><span class="line">...     for name, value in kwargs.items():</span><br><span class="line">...         print &apos;&#123;0&#125; = &#123;1&#125;&apos;.format(name, value)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure></p>
<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.</span><br></pre></td></tr></table></figure>
<p>当调用函数时你也可以用*和**语法.例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_three_things(a, b, c):</span><br><span class="line">...     print &apos;a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;&apos;.format(a,b,c)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; mylist = [&apos;aardvark&apos;, &apos;baboon&apos;, &apos;cat&apos;]</span><br><span class="line">&gt;&gt;&gt; print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure></p>
<p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.<br><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="noopener">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>
<hr>
<h4 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h4><p>这个AOP一听起来有点懵，下面做下解释；Java的spring框架中有OOP编程，而AOP可以看成是OOP的补充。</p>
<blockquote>
<p>面向切面编程（AOP是Aspect Oriented Program的缩写），我们知道，面向对象的特点是继承<br>多态和封装。而封装就是将不同的功能分散到不同的对象中去，这种设计往往在软件设计中叫做职责分配。实际上就是说让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处就是降低了代码的复杂程度，使类可以重用。<br>但是人们发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？就是比如说，我们两个类中，可能都需要在每个方法上做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入写日志的内容。即使写日志的代码都相同；但就是因为面向对象的设计方法让类与类之间是无法联系的，而不能将这些代码统一起来。<br>也许会有人说，那好办呐，我们可以将写日志的这段代码写在一个独立类的方法里，然后在这两个类中调用。但是这样一来，这两个类跟我们上面提到的独立的类就有耦合了，他的改变会影响到这两个类。（这里就是耦合的弊端）有什么解决办法呢？能让我们在需要的时候随意的插入功能代码？<br><strong>这种在运行时，动态的将特定的功能代码将入到（切入到）类的指定的方法、指定位置上的编程思想就是面向切面的编程</strong><br>一般而言，我们管切入到指定类的指定方法的代码片段称之为切面，而切入到哪些类，哪些方法则叫做切入点。有了AOP，我们就可以将几个类共有的功能代码，抽取到一个切面中，等到需要的时候再切入到对象中去，从而改变其原有的行为。<br>这样看来，AOP其实是OOP的补充而已。OOP从横向的区分出一个个类来，而AOP则从纵向上像对象中加入特定的代码。有了AOP，OOP就变的立体了。如果加上时间的纬度，AOP使OOP有原来的二位变为了三维，有平面变成了立体。从技术上说AOP基本上是通过代码机制实现的。<br>AOP在编程历史上可以说是里程碑式的，对OOP是一种补充。</p>
</blockquote>
<p>而在Python中面向切面编程便是Python中的语法糖装饰器。装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有日志的插入，性能的测试、事物的处理等。装饰器是解决这类问题的绝佳的设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同的代码并可以继续的重用。概括的讲装饰器的作用就是为已经存在的对象添加额外的功能。<br>这个问题比较大，推荐：<a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a><br>中文：<a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p>
<hr>
<h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>“当你看到一张鸟走起来像鸭子，游起泳来像鸭子、叫起来也像鸭子，那么可以称这只鸟为鸭子”。</p>
<blockquote>
<p>我们并不关心对象是什么类型（到底是不是鸭子），我们只关心它的行为。<br>鸭子类型的使用，经常出现在动态语言中，非常的灵活。<br>比如在Python中，有很多file-like的东西，比如StringIO，GzipFile，socket。他们有很多相同的方法，我们把它们当做文件使用。<br>又比如：list.extend()，我们不关心它的参数是不是list，只要它是可迭代的，所以它的参数可以是list/tuple/dict/字符串/生成器等。<br>这样使得Python不像java那样专门去弄一大推的设计模式。</p>
</blockquote>
<hr>
<h4 id="Python中的重载"><a href="#Python中的重载" class="headerlink" title="Python中的重载"></a>Python中的重载</h4><blockquote>
<p>Python中其实不需要做函数的重载</p>
</blockquote>
<p>函数的重载主要是为了解决两个问题。</p>
<ul>
<li>可变参数类型</li>
<li>可变参数个数</li>
</ul>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型个参数个数不同以外，其功能是完全的相同的，此时才需要用到函数的重载，如果两个函数的功能本来就是不同的，那么就不应当使用重载，而应当使用一个名字不同的函数。<br>好吧，那么对于情况1，函数功能相同，但是参数的类型不同，Python如何的处理？答案是根本不需要处理，因为Python可以接收任何类型的参数，如果函数的功能相同，那么不同的参数类型在Python中很可能是相同的代码，则没有必要做成两个函数。<br>那么对于情况2，函数功能相同，但是函数的参数个数不同，Python如何处理？大家都知道，那就是缺省参数。对于那些缺少的参数将其设定为缺省参数即可解决问题。因为你假设函数的功能相同，那么那些缺少的参数最终还是需要用到的。<br>好了，鉴于情况1更情况2都有了解决方案，Python自然就不需要进行函数的重载了。</p>
<hr>
<h4 id="新式类和旧式类"><a href="#新式类和旧式类" class="headerlink" title="新式类和旧式类"></a>新式类和旧式类</h4><blockquote>
<p>提前说明一下，新式类的查找顺序是广度优先，而旧式类的查找顺序是深度优先</p>
</blockquote>
<p>这里有一篇文藏很好的介绍了新式类的特性：<a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="noopener">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a><br>新式类很在在2.2中就已经出现了，所以旧式类则完全沦为了兼容的问题，Python3里的类全部都是新式类。这里有一个MRO问题可以了解一下（新式类是广度优先，旧式类是深度优先）</p>
<blockquote>
<p>一个旧式类的深度优先的例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A():</span><br><span class="line">    def foo1(self):</span><br><span class="line">        print &quot;A&quot;</span><br><span class="line">class B(A):</span><br><span class="line">    def foo2(self):</span><br><span class="line">        pass</span><br><span class="line">class C(A):</span><br><span class="line">    def foo1(self):</span><br><span class="line">        print &quot;C&quot;</span><br><span class="line">class D(B, C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo1()</span><br><span class="line"></span><br><span class="line"># A</span><br></pre></td></tr></table></figure>
<p>按照经典的查找顺序，从做到右深度优先的原则，在访问<code>d.foo1()</code>的时候，D这个类是没有具体的实现的，那么往上查找，先找到B，B里面也没有，深度优先访问到A，找到了<code>foo1()</code>所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过。</p>
<hr>
<h4 id="new和init的区别"><a href="#new和init的区别" class="headerlink" title="new和init的区别"></a><strong>new</strong>和<strong>init</strong>的区别</h4><blockquote>
<p><code>__new__返回个一个cls的静态实例</code>，只有当返回cls的静态实例后<code>__init__</code>才会被调用<br>实际上就是一个调用先后的问题，一般不用重写<code>__new__</code>。</p>
</blockquote>
<ul>
<li><code>__new__</code>是一个静态方法，而<code>__init__</code>是一个实例方法。</li>
<li><code>__new__</code>方法返回一个创建的实例，而<code>__init__</code>什么都不返回。</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才被调用。</li>
<li>当创建一个新的实例时调用<code>__new__</code>，初始化一个实例时用<code>__init__</code>。</li>
</ul>
<p><a href="https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new" target="_blank" rel="noopener">stackoverflow</a><br>ps：<code>__metaclass__</code>是创建类是起作用，所以我们分别使用<code>__metaclass__</code>，<code>__new__</code>和<code>__init__</code>来分别在在类创建，实例创建和实例初始化的时候做一些小的手脚。</p>
<hr>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote>
<p>单例模式是一种软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例的模式保证系统中一个类之后一个实例而且该实例易于被外界访问。从而方便对实例的个数控制并节省系统得资源。如果希望在系统中的某个类的对象只能存在一个，单例模式是最好的解决方案。<br><code>__new__</code>在<code>__init__</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可是实现设计模式的单例模式。单例模式是指创建唯一的对象，单例模式的类只能实例。</p>
</blockquote>
<p>一下介绍几种方法：</p>
<ul>
<li>使用<code>__new__</code>方法结合共享属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        if not hasattr(cls, &apos;_instance&apos;):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure>
<ul>
<li>共享属性</li>
</ul>
<p>创建实例时把所有的<code>__dict__</code>指向同一个字典，这样他们就具有了相同的属性和方法，具有了相同的属性和方法Python中就不需要进行重载，它们本省就是同一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Borg(object):</span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        return ob</span><br><span class="line"></span><br><span class="line">class MyClass2(Borg):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure></p>
<ul>
<li>装饰器版本的共享属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls, *args, **kw):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    def getinstance():</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    return getinstance</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class MyClass:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<ul>
<li>import方法</li>
</ul>
<p>作为Python的模块是天然的单例模式，当然要选择合适的应用场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"># to use</span><br><span class="line">from mysingleton import my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Python中的作用域"><a href="#Python中的作用域" class="headerlink" title="Python中的作用域"></a>Python中的作用域</h4><blockquote>
<p>Python中，一个变量的作用域总是在代码中被赋值的地方所决定的。</p>
</blockquote>
<p>当Python遇到一个变量的话他会按照这样的顺序进行搜索：<br>本地作用域（Local）-&gt;当前作用域被嵌入的本地作用域（Enclosing locals）-&gt;全局/模块作用域-&gt;内置作用域（Built-in）</p>
<hr>
<h4 id="GIL线程全局锁"><a href="#GIL线程全局锁" class="headerlink" title="GIL线程全局锁"></a>GIL线程全局锁</h4><blockquote>
<p>GIL是针对Python下的多线程来讲的</p>
</blockquote>
<p>线程全局锁（Global Interpreter Lock），即Python为了保证线程安全而采取的独立线程运行的限制，说白了就是一个核只能在同一时间运行一个线程。对于IO密集型任务，Python的所线程可以起到作用，但对于CPU密集型任务，Python的多线程几乎占不到任何的优势，还有可能会因为资源的争夺而变慢。<br>详细见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python最难的问题</a><br>解决办法就是多进程和下面的协程（协程也只是单CPU，但是能减小切换代价提升性能）。</p>
<hr>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><blockquote>
<p>简单点说协程是进程和线程的升级版</p>
</blockquote>
<p>进程和线程都面临着内核态和用户态的切换问题而耗费许多的切换的时间，而协程就是用户自己控制切换的时机，不再需要陷入系统得内核态。<br>Python里最常见的yiled就是协程的思想！</p>
<hr>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote>
<p>闭包（closure）是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>
</blockquote>
<p>当一个内嵌函数引用其外部作用域的变量，我们就会得到一个闭包，总结一下创建一个闭包必须满足以下几点：</p>
<ul>
<li>必须要有一个内嵌的函数。</li>
<li>内嵌函数必须引用外部函数中的变量。</li>
<li>外部函数的返回值必须是内嵌函数。</li>
</ul>
<p>感觉闭包还是有难度的，几句话是说不明白的，还是查查相关的资料吧。<br>重点是函数运行之后并不会被撤销，就像上面的单例模式中的装饰器方法中的instance字典一样，当函数运行完之后，instance并不销毁，而是继续保存在内存空间里。这个功能类似类里的类变量，只不过迁移到了函数上。<br>闭包就像个空心球一样，你知道外面和里面，但你不知道中间是什么样的。</p>
<hr>
<h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><blockquote>
<p>其实就是一个匿名的函数，为什么引入lambda，是为了函数式编程不用再去重新定义小功能的函数</p>
</blockquote>
<p>推荐阅读：<a href="https://www.zhihu.com/question/20125256" target="_blank" rel="noopener">知乎</a></p>
<hr>
<h4 id="Python函数式编程"><a href="#Python函数式编程" class="headerlink" title="Python函数式编程"></a>Python函数式编程</h4><blockquote>
<p>Python中函数式编程主要用到的高阶函数有filter，map，reduce和列表及字典解析，将它们嵌套lambda使用。</p>
</blockquote>
<p>推荐阅读： <a href="https://coolshell.cn/articles/10822.html" target="_blank" rel="noopener">酷壳</a><br>Python中函数式编程的支持：</p>
<ul>
<li>fliter函数</li>
</ul>
<p>filter函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来遍历每个可迭代集合中的每一个对象，返回一个使<code>bool_seq</code>返回值为true的元素序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3,4,5,6,7]</span><br><span class="line">&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)</span><br><span class="line">&gt;&gt;&gt;print b</span><br><span class="line">&gt;&gt;&gt;[6,7]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>map函数</li>
</ul>
<p>map函数是对一个序列的每个项依次执行定义好的函数，下面是对序列的每一项都乘以2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])</span><br><span class="line">&gt;&gt;&gt; list(a)</span><br><span class="line">[2, 4, 6]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>reduce函数</li>
</ul>
<p>reduce函数是对一个序列的每个项迭代调用函数。下面是求3的阶乘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h4><blockquote>
<p>Python里的拷贝分浅拷贝和深拷贝，浅拷贝不追踪对象的时间维度节点，深拷贝始终追踪对象的时间维度节点。</p>
</blockquote>
<p>在这里引用copy()，deepcopy()的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]  #原始对象</span><br><span class="line"></span><br><span class="line">b = a  #赋值，传对象的引用</span><br><span class="line">c = copy.copy(a)  #对象拷贝，浅拷贝</span><br><span class="line">d = copy.deepcopy(a)  #对象拷贝，深拷贝</span><br><span class="line"></span><br><span class="line">a.append(5)  #修改对象a</span><br><span class="line">a[4].append(&apos;c&apos;)  #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象</span><br><span class="line"></span><br><span class="line">print &apos;a = &apos;, a</span><br><span class="line">print &apos;b = &apos;, b</span><br><span class="line">print &apos;c = &apos;, c</span><br><span class="line">print &apos;d = &apos;, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line">b =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line">c =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br><span class="line">d =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h4><blockquote>
<p> Python GC主要使用引用计数（reference counting）来追踪和回收垃圾。在引用计数的基础上。通过“标记”和“清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收的效率。</p>
</blockquote>
<ul>
<li>引用计数</li>
</ul>
<p>PyObject是每个对象必有的内容。其中<code>ob_refcnt</code>就是作为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象删除时，它的<code>ob_refcnt</code>就会减少，当引用的计数为0时，该对象的生命就结束了。</p>
<p>优点：<br>1、简单。<br>2、实时性。</p>
<p>缺点：<br>1、维护引用计数消耗资源。<br>2、循环引用。</p>
<ul>
<li>标记-清除机制</li>
</ul>
<p>基本的思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点，以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没有标记的对象释放。</p>
<ul>
<li>分代技术</li>
</ul>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活的时间划分为不同的集合，每个集合就成为了一个“代”，垃圾的收集频率随着“代”的存活的时间的增大而减小，存活的时间通常利用经过几次垃圾回收来度量。</p>
<p>Python默认定义了三代对象集合，索引数越大，对象的存活时间就越长。</p>
<p>举例：当某些内存块M经过了3次垃圾收集的清洗后如果还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集的工作开始时，大多数的情况就只针对B集合进行垃圾回收，而对集合A进行垃圾回收要间隔相当长的一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，回收工作本身占用的系统资源减少，效率自然就提高了。这这个过程中，集合B中的某些内存块由于存活时间较长而被转移到集合A中，当然，集合A中实际上也会存在一些的垃圾，这些垃圾的回收会因为这种分代的机制而被延迟回收。</p>
<hr>
<h4 id="Python的List"><a href="#Python的List" class="headerlink" title="Python的List"></a>Python的List</h4><p>推荐阅读：<a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="noopener">http://www.jianshu.com/p/J4U6rR</a></p>
<hr>
<h4 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h4><p>is是对比地址，==是对比值。</p>
<hr>
<h4 id="read，readline和readlines"><a href="#read，readline和readlines" class="headerlink" title="read，readline和readlines"></a>read，readline和readlines</h4><blockquote>
<p>read 读取整个文件<br>readline 读取下一行，使用生成器的方法<br>readlines 读取整个文件到一个迭代器以供我们遍历</p>
</blockquote>
<hr>
<h4 id="Python2和3的区别"><a href="#Python2和3的区别" class="headerlink" title="Python2和3的区别"></a>Python2和3的区别</h4><p>推荐阅读：Python 2.7.x 与 Python 3.x 的主要差异</p>
<hr>
<h4 id="super-init"><a href="#super-init" class="headerlink" title="super init"></a>super init</h4><p>super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already.</p>
<p>Note that the syntax changed in Python 3.0: you can just say super().<strong>init</strong>() instead of super(ChildB, self).<strong>init</strong>() which IMO is quite a bit nicer.</p>
<p><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods" target="_blank" rel="noopener">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a></p>
<p><a href="http://blog.csdn.net/mrlevo520/article/details/51712440" target="_blank" rel="noopener">Python2.7中的super方法浅见</a></p>
<hr>
<h4 id="range-and-xrange"><a href="#range-and-xrange" class="headerlink" title="range and xrange"></a>range and xrange</h4><p>都是在循环的时候使用，xrange内存的性能更好。for i in range(0, 20): for i in xrange(0, 20): What is the difference between range and xrange functions in Python 2.X? range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. xrange is a sequence object that evaluates lazily.</p>
<p><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x" target="_blank" rel="noopener">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python面试题/" <i class="fa fa-tag"></i> python面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/22/hexo从0到1个性化博客搭建之环境集成/" rel="next" title="hexo从0到1个性化博客搭之环境集成">
                <i class="fa fa-chevron-left"></i> hexo从0到1个性化博客搭之环境集成
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/10/最新python面试题之操作系统/" rel="prev" title="最新python面试题之操作系统">
                最新python面试题之操作系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/max.jpg"
                alt="洋葱头gg" />
            
              <p class="site-author-name" itemprop="name">洋葱头gg</p>
              <p class="site-description motion-element" itemprop="description">好看的皮囊千篇一律,有趣的灵魂一二百斤</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yangcongtougg" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.jianshu.com/users/c2b72fe5b7f6" target="_blank" title="简书">
                    
                      <i class="fa fa-fw fa-globe"></i>简书</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="maxzhangcong@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python面试题"><span class="nav-number">1.</span> <span class="nav-text"><a href="#Python&#x9762;&#x8BD5;&#x9898;" class="headerlink" title="Python&#x9762;&#x8BD5;&#x9898;"></a>Python&#x9762;&#x8BD5;&#x9898;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#python的函数参数传递"><span class="nav-number">1.0.1.</span> <span class="nav-text"><a href="#python&#x7684;&#x51FD;&#x6570;&#x53C2;&#x6570;&#x4F20;&#x9012;" class="headerlink" title="python&#x7684;&#x51FD;&#x6570;&#x53C2;&#x6570;&#x4F20;&#x9012;"></a>python&#x7684;&#x51FD;&#x6570;&#x53C2;&#x6570;&#x4F20;&#x9012;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python中的元类"><span class="nav-number">1.0.2.</span> <span class="nav-text"><a href="#Python&#x4E2D;&#x7684;&#x5143;&#x7C7B;" class="headerlink" title="Python&#x4E2D;&#x7684;&#x5143;&#x7C7B;"></a>Python&#x4E2D;&#x7684;&#x5143;&#x7C7B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#staticmethod和-classmethod"><span class="nav-number">1.0.3.</span> <span class="nav-text"><a href="#staticmethod&#x548C;-classmethod" class="headerlink" title="@ staticmethod&#x548C;@ classmethod"></a>@ staticmethod&#x548C;@ classmethod</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类变量和实例变量"><span class="nav-number">1.0.4.</span> <span class="nav-text"><a href="#&#x7C7B;&#x53D8;&#x91CF;&#x548C;&#x5B9E;&#x4F8B;&#x53D8;&#x91CF;" class="headerlink" title="&#x7C7B;&#x53D8;&#x91CF;&#x548C;&#x5B9E;&#x4F8B;&#x53D8;&#x91CF;"></a>&#x7C7B;&#x53D8;&#x91CF;&#x548C;&#x5B9E;&#x4F8B;&#x53D8;&#x91CF;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类变量："><span class="nav-number">1.0.4.1.</span> <span class="nav-text"><a href="#&#x7C7B;&#x53D8;&#x91CF;&#xFF1A;" class="headerlink" title="&#x7C7B;&#x53D8;&#x91CF;&#xFF1A;"></a>&#x7C7B;&#x53D8;&#x91CF;&#xFF1A;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例变量："><span class="nav-number">1.0.4.2.</span> <span class="nav-text"><a href="#&#x5B9E;&#x4F8B;&#x53D8;&#x91CF;&#xFF1A;" class="headerlink" title="&#x5B9E;&#x4F8B;&#x53D8;&#x91CF;&#xFF1A;"></a>&#x5B9E;&#x4F8B;&#x53D8;&#x91CF;&#xFF1A;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python的自省"><span class="nav-number">1.0.5.</span> <span class="nav-text"><a href="#Python&#x7684;&#x81EA;&#x7701;" class="headerlink" title="Python&#x7684;&#x81EA;&#x7701;"></a>Python&#x7684;&#x81EA;&#x7701;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字典推导式"><span class="nav-number">1.0.6.</span> <span class="nav-text"><a href="#&#x5B57;&#x5178;&#x63A8;&#x5BFC;&#x5F0F;" class="headerlink" title="&#x5B57;&#x5178;&#x63A8;&#x5BFC;&#x5F0F;"></a>&#x5B57;&#x5178;&#x63A8;&#x5BFC;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python中单下划线和双下划线"><span class="nav-number">1.0.7.</span> <span class="nav-text"><a href="#Python&#x4E2D;&#x5355;&#x4E0B;&#x5212;&#x7EBF;&#x548C;&#x53CC;&#x4E0B;&#x5212;&#x7EBF;" class="headerlink" title="Python&#x4E2D;&#x5355;&#x4E0B;&#x5212;&#x7EBF;&#x548C;&#x53CC;&#x4E0B;&#x5212;&#x7EBF;"></a>Python&#x4E2D;&#x5355;&#x4E0B;&#x5212;&#x7EBF;&#x548C;&#x53CC;&#x4E0B;&#x5212;&#x7EBF;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串格式化：-和-format"><span class="nav-number">1.0.8.</span> <span class="nav-text"><a href="#&#x5B57;&#x7B26;&#x4E32;&#x683C;&#x5F0F;&#x5316;&#xFF1A;-&#x548C;-format" class="headerlink" title="&#x5B57;&#x7B26;&#x4E32;&#x683C;&#x5F0F;&#x5316;&#xFF1A;%&#x548C;.format"></a>&#x5B57;&#x7B26;&#x4E32;&#x683C;&#x5F0F;&#x5316;&#xFF1A;%&#x548C;.format</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器和生成器"><span class="nav-number">1.0.9.</span> <span class="nav-text"><a href="#&#x8FED;&#x4EE3;&#x5668;&#x548C;&#x751F;&#x6210;&#x5668;" class="headerlink" title="&#x8FED;&#x4EE3;&#x5668;&#x548C;&#x751F;&#x6210;&#x5668;"></a>&#x8FED;&#x4EE3;&#x5668;&#x548C;&#x751F;&#x6210;&#x5668;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#args-and-kwargs"><span class="nav-number">1.0.10.</span> <span class="nav-text"><a href="#args-and-kwargs" class="headerlink" title="*args and **kwargs"></a>*args and **kwargs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向切面编程AOP和装饰器"><span class="nav-number">1.0.11.</span> <span class="nav-text"><a href="#&#x9762;&#x5411;&#x5207;&#x9762;&#x7F16;&#x7A0B;AOP&#x548C;&#x88C5;&#x9970;&#x5668;" class="headerlink" title="&#x9762;&#x5411;&#x5207;&#x9762;&#x7F16;&#x7A0B;AOP&#x548C;&#x88C5;&#x9970;&#x5668;"></a>&#x9762;&#x5411;&#x5207;&#x9762;&#x7F16;&#x7A0B;AOP&#x548C;&#x88C5;&#x9970;&#x5668;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#鸭子类型"><span class="nav-number">1.0.12.</span> <span class="nav-text"><a href="#&#x9E2D;&#x5B50;&#x7C7B;&#x578B;" class="headerlink" title="&#x9E2D;&#x5B50;&#x7C7B;&#x578B;"></a>&#x9E2D;&#x5B50;&#x7C7B;&#x578B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python中的重载"><span class="nav-number">1.0.13.</span> <span class="nav-text"><a href="#Python&#x4E2D;&#x7684;&#x91CD;&#x8F7D;" class="headerlink" title="Python&#x4E2D;&#x7684;&#x91CD;&#x8F7D;"></a>Python&#x4E2D;&#x7684;&#x91CD;&#x8F7D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新式类和旧式类"><span class="nav-number">1.0.14.</span> <span class="nav-text"><a href="#&#x65B0;&#x5F0F;&#x7C7B;&#x548C;&#x65E7;&#x5F0F;&#x7C7B;" class="headerlink" title="&#x65B0;&#x5F0F;&#x7C7B;&#x548C;&#x65E7;&#x5F0F;&#x7C7B;"></a>&#x65B0;&#x5F0F;&#x7C7B;&#x548C;&#x65E7;&#x5F0F;&#x7C7B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new和init的区别"><span class="nav-number">1.0.15.</span> <span class="nav-text"><a href="#new&#x548C;init&#x7684;&#x533A;&#x522B;" class="headerlink" title="new&#x548C;init&#x7684;&#x533A;&#x522B;"></a><strong>new</strong>&#x548C;<strong>init</strong>&#x7684;&#x533A;&#x522B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式"><span class="nav-number">1.0.16.</span> <span class="nav-text"><a href="#&#x5355;&#x4F8B;&#x6A21;&#x5F0F;" class="headerlink" title="&#x5355;&#x4F8B;&#x6A21;&#x5F0F;"></a>&#x5355;&#x4F8B;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python中的作用域"><span class="nav-number">1.0.17.</span> <span class="nav-text"><a href="#Python&#x4E2D;&#x7684;&#x4F5C;&#x7528;&#x57DF;" class="headerlink" title="Python&#x4E2D;&#x7684;&#x4F5C;&#x7528;&#x57DF;"></a>Python&#x4E2D;&#x7684;&#x4F5C;&#x7528;&#x57DF;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GIL线程全局锁"><span class="nav-number">1.0.18.</span> <span class="nav-text"><a href="#GIL&#x7EBF;&#x7A0B;&#x5168;&#x5C40;&#x9501;" class="headerlink" title="GIL&#x7EBF;&#x7A0B;&#x5168;&#x5C40;&#x9501;"></a>GIL&#x7EBF;&#x7A0B;&#x5168;&#x5C40;&#x9501;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协程"><span class="nav-number">1.0.19.</span> <span class="nav-text"><a href="#&#x534F;&#x7A0B;" class="headerlink" title="&#x534F;&#x7A0B;"></a>&#x534F;&#x7A0B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包"><span class="nav-number">1.0.20.</span> <span class="nav-text"><a href="#&#x95ED;&#x5305;" class="headerlink" title="&#x95ED;&#x5305;"></a>&#x95ED;&#x5305;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda函数"><span class="nav-number">1.0.21.</span> <span class="nav-text"><a href="#lambda&#x51FD;&#x6570;" class="headerlink" title="lambda&#x51FD;&#x6570;"></a>lambda&#x51FD;&#x6570;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python函数式编程"><span class="nav-number">1.0.22.</span> <span class="nav-text"><a href="#Python&#x51FD;&#x6570;&#x5F0F;&#x7F16;&#x7A0B;" class="headerlink" title="Python&#x51FD;&#x6570;&#x5F0F;&#x7F16;&#x7A0B;"></a>Python&#x51FD;&#x6570;&#x5F0F;&#x7F16;&#x7A0B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python里的拷贝"><span class="nav-number">1.0.23.</span> <span class="nav-text"><a href="#Python&#x91CC;&#x7684;&#x62F7;&#x8D1D;" class="headerlink" title="Python&#x91CC;&#x7684;&#x62F7;&#x8D1D;"></a>Python&#x91CC;&#x7684;&#x62F7;&#x8D1D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python垃圾回收机制"><span class="nav-number">1.0.24.</span> <span class="nav-text"><a href="#Python&#x5783;&#x573E;&#x56DE;&#x6536;&#x673A;&#x5236;" class="headerlink" title="Python&#x5783;&#x573E;&#x56DE;&#x6536;&#x673A;&#x5236;"></a>Python&#x5783;&#x573E;&#x56DE;&#x6536;&#x673A;&#x5236;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python的List"><span class="nav-number">1.0.25.</span> <span class="nav-text"><a href="#Python&#x7684;List" class="headerlink" title="Python&#x7684;List"></a>Python&#x7684;List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python的is"><span class="nav-number">1.0.26.</span> <span class="nav-text"><a href="#Python&#x7684;is" class="headerlink" title="Python&#x7684;is"></a>Python&#x7684;is</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read，readline和readlines"><span class="nav-number">1.0.27.</span> <span class="nav-text"><a href="#read&#xFF0C;readline&#x548C;readlines" class="headerlink" title="read&#xFF0C;readline&#x548C;readlines"></a>read&#xFF0C;readline&#x548C;readlines</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python2和3的区别"><span class="nav-number">1.0.28.</span> <span class="nav-text"><a href="#Python2&#x548C;3&#x7684;&#x533A;&#x522B;" class="headerlink" title="Python2&#x548C;3&#x7684;&#x533A;&#x522B;"></a>Python2&#x548C;3&#x7684;&#x533A;&#x522B;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-init"><span class="nav-number">1.0.29.</span> <span class="nav-text"><a href="#super-init" class="headerlink" title="super init"></a>super init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#range-and-xrange"><span class="nav-number">1.0.30.</span> <span class="nav-text"><a href="#range-and-xrange" class="headerlink" title="range and xrange"></a>range and xrange</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv">
  共<span id="busuanzi_value_site_uv"></span>位小伙伴留下脚印
</span>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Powered-By洋葱头gg</span>

  
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="20" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
</body>
</html>
