<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洋葱头gg&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-22T10:17:35.167Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>洋葱头gg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python高效编程技巧之数据结构相关</title>
    <link href="http://yoursite.com/2018/01/22/python%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/01/22/python高效编程技巧之数据结构相关/</id>
    <published>2018-01-22T06:50:03.000Z</published>
    <updated>2018-01-22T10:17:35.167Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客在于记录python高效编程之数据结构相关的编程技巧。</p></blockquote><h4 id="如何在列表、字典、集合中根据条件删选数据"><a href="#如何在列表、字典、集合中根据条件删选数据" class="headerlink" title="如何在列表、字典、集合中根据条件删选数据"></a>如何在列表、字典、集合中根据条件删选数据</h4><h5 id="列表筛选元素"><a href="#列表筛选元素" class="headerlink" title="列表筛选元素"></a>列表筛选元素</h5><blockquote><p>筛选数据，最最常用的就是for循环及迭代，而相关的高级用法就是filter函数，列表解析、字典解析以及集合解析。</p></blockquote><p>举个栗子：生成一个随机的列表，过滤掉其中小于0的数字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">a = [randint(<span class="number">-10</span>, <span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">f = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        f.append(i)</span><br><span class="line">print(f)</span><br><span class="line"></span><br><span class="line">b = filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>, a)  <span class="comment"># filter 函数过过滤</span></span><br><span class="line">print(list(b))</span><br><span class="line"></span><br><span class="line">c = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &gt; <span class="number">0</span>]  <span class="comment"># 列表解析过滤</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></p><blockquote><p>其中使用到了迭代、filter函数和列表解析，推荐使用filter函数和列表解析。<br>filter函数接收的第一个参数为函数，这里使用了lambda匿名函数（推荐使用匿名函数），第二个参数传入可迭代对象。</p></blockquote><hr><p>现在我们来对迭代，filter和列表解析来进行一下运行时间的比较：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_running_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        rep = func(*args, **kwargs)</span><br><span class="line">        time.sleep(<span class="number">2</span>)<span class="comment"># 时间执行太短，加入干扰</span></span><br><span class="line">        print(<span class="string">'&#123;0&#125;函数运行了&#123;1&#125;秒'</span>.format(func.__name__, time.time()-start))</span><br><span class="line">        <span class="keyword">return</span> rep</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_arr</span><span class="params">(m1, m2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [randint(m1, m2) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="comment"># 生成随机列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@count_running_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_filter</span><span class="params">(m1)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>, m1)) <span class="comment"># filter 函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@count_running_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_listanalysis</span><span class="params">(m1)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> m1 <span class="keyword">if</span> i &gt; <span class="number">0</span>] <span class="comment"># 列表解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    a = random_arr(<span class="number">-10</span>, <span class="number">10</span>)</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">    b = my_filter(a)</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">    c = my_listanalysis(a)</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure></p><p>打印的结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">8</span>, <span class="number">-10</span>, <span class="number">-6</span>, <span class="number">-1</span>]</span><br><span class="line">my_filter函数运行了<span class="number">2.0003464221954346</span>秒</span><br><span class="line">[<span class="number">5</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">my_listanalysis函数运行了<span class="number">2.0003223419189453</span>秒</span><br><span class="line">[<span class="number">5</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p><p>我们可以看到列表解析的速度相对快一些，推荐使用列表解析的方式。</p><hr><h5 id="字典筛选元素"><a href="#字典筛选元素" class="headerlink" title="字典筛选元素"></a>字典筛选元素</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">a = &#123;x: randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>)&#125; <span class="comment"># 随机生成60到100分7个人</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> a.items() <span class="keyword">if</span> value &gt; <span class="number">90</span>&#125;</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><hr><h5 id="筛选集合元素"><a href="#筛选集合元素" class="headerlink" title="筛选集合元素"></a>筛选集合元素</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = [randint(<span class="number">-10</span>, <span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">s = set(data)</span><br><span class="line">filter_s = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>&#125; <span class="comment"># 筛选集合中能被3整除的数</span></span><br><span class="line">print(filter_s)</span><br></pre></td></tr></table></figure><hr><h4 id="如何为元组中的每个元素进行命名，提高程序的可读性"><a href="#如何为元组中的每个元素进行命名，提高程序的可读性" class="headerlink" title="如何为元组中的每个元素进行命名，提高程序的可读性"></a>如何为元组中的每个元素进行命名，提高程序的可读性</h4><blockquote><p>这样一来我们使用index来访问的时候就可以避免大量的索引值</p></blockquote><h5 id="手动添加索引值"><a href="#手动添加索引值" class="headerlink" title="手动添加索引值"></a>手动添加索引值</h5><p>举个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NAME = <span class="number">0</span></span><br><span class="line">AGE = <span class="number">1</span></span><br><span class="line">SEX = <span class="number">2</span></span><br><span class="line">EMAIL = <span class="number">3</span></span><br><span class="line"><span class="comment"># 或者使用下面的</span></span><br><span class="line">NAME, AGE, SEX, EMAIL = range(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">student = (<span class="string">'zhangcong'</span>, <span class="number">18</span>, <span class="string">'male'</span>, <span class="string">'123@qq.com'</span>)</span><br><span class="line">print(student[NAME])</span><br><span class="line">print(student[AGE])</span><br><span class="line">print(student[SEX])</span><br><span class="line">print(student[EMAIL])</span><br></pre></td></tr></table></figure></p><p>student元组对象在进行初始化的时候一定要依次按照顺序</p><hr><h5 id="使用标准库中的namedtuple"><a href="#使用标准库中的namedtuple" class="headerlink" title="使用标准库中的namedtuple"></a>使用标准库中的namedtuple</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">student = namedtuple(<span class="string">'Student'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>, <span class="string">'email'</span>])</span><br><span class="line">s = student(<span class="string">'zhangcong'</span>, <span class="number">18</span>, <span class="string">'male'</span>, <span class="string">'123@qq.com'</span>)</span><br><span class="line">s2 = student(name=<span class="string">'123'</span>, age=<span class="number">20</span>, sex=<span class="string">''</span>, email=<span class="string">''</span>)</span><br><span class="line">print(s)</span><br><span class="line">print(s.name)</span><br><span class="line">print(s2)</span><br><span class="line">print(s2.name)</span><br><span class="line"></span><br><span class="line">print(isinstance(s, tuple))  <span class="comment"># s是一个元组</span></span><br></pre></td></tr></table></figure><p>使用namedtuple()，第一个参数传入元组的对象名，第二个参数传入索引值列表，student初始化时有两种方式，一种是按照顺序初始化，一种是按照索引值进行初始化。</p><hr><h4 id="统计序列中元素出现的频率，字符串中字符出现的频率"><a href="#统计序列中元素出现的频率，字符串中字符出现的频率" class="headerlink" title="统计序列中元素出现的频率，字符串中字符出现的频率"></a>统计序列中元素出现的频率，字符串中字符出现的频率</h4><h5 id="常规迭代方式"><a href="#常规迭代方式" class="headerlink" title="常规迭代方式"></a>常规迭代方式</h5><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">data = [randint(<span class="number">1</span>, <span class="number">30</span>)<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">30</span>)] <span class="comment"># 随机生成30个1到30的数字的列表</span></span><br><span class="line">print(data)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">根据列表，生成以列表值为key，value为0的字典，对data进行迭代，没遇见一次元素，a字典中的value+1，</span></span><br><span class="line"><span class="string">最终统计数字出现的次数 key:数字，value:出现的次数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a = dict.fromkeys(data, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">    a[x] += <span class="number">1</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><hr><h5 id="使用标准库中的Counter对象统计前三项"><a href="#使用标准库中的Counter对象统计前三项" class="headerlink" title="使用标准库中的Counter对象统计前三项"></a>使用标准库中的Counter对象统计前三项</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">data = [randint(<span class="number">1</span>, <span class="number">30</span>)<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">30</span>)]</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">a = dict.fromkeys(data, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:<span class="comment"># 迭代data 每遇见一次元素 a字典中的value+1</span></span><br><span class="line">    a[x] += <span class="number">1</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">a1 = Counter(a)</span><br><span class="line">most_number = a1.most_common(<span class="number">3</span>) <span class="comment"># dict_a前三项</span></span><br><span class="line">print(most_number)</span><br><span class="line"></span><br><span class="line">a2 = Counter(data)</span><br><span class="line">most_number = a2.most_common(<span class="number">3</span>) <span class="comment"># list_data前三项</span></span><br><span class="line">print(most_number_data)</span><br></pre></td></tr></table></figure><p>可以看出使用most_common方式可以快速的得出前三项的值（参数为3），创建Counter对象时传入的参数可以是list，也可以是dict，亦可以时set集合。</p><hr><h5 id="统计字符出现的次数"><a href="#统计字符出现的次数" class="headerlink" title="统计字符出现的次数"></a>统计字符出现的次数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = open(<span class="string">r'C:\Users\renrenlabzc\Desktop\***.txt'</span>).read()</span><br><span class="line">keyword_list = re.split(<span class="string">'\W+'</span>, text) <span class="comment"># 根据正则，将字符串以不是标点符号的字符分割为list</span></span><br><span class="line">m = Counter(keyword_list)</span><br><span class="line">n = m.most_common(<span class="number">3</span>)</span><br><span class="line">print(n) <span class="comment"># 打印出现次数前三的单词</span></span><br></pre></td></tr></table></figure><hr><h4 id="对列表及字典排序"><a href="#对列表及字典排序" class="headerlink" title="对列表及字典排序"></a>对列表及字典排序</h4><blockquote><p>使用内置的sorted内置函数进行排序，会结合使用到zip函数。</p></blockquote><h5 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">data = [randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">a = sorted(data, reverse=<span class="keyword">True</span>) <span class="comment"># reverse=True 降序 = False升序</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><hr><h5 id="字典进行排序"><a href="#字典进行排序" class="headerlink" title="字典进行排序"></a>字典进行排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">dict_a = &#123;key: randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> key <span class="keyword">in</span> <span class="string">'abcdefg'</span>&#125; <span class="comment"># 随机生成adc....学生的成绩dict</span></span><br><span class="line">print(dict_a)</span><br><span class="line"></span><br><span class="line">a = sorted(dict_a，reverse=<span class="keyword">True</span>)</span><br><span class="line">print(a)   <span class="comment">#直接传入字典的话，用到了字典key的可迭代性，此时的value是不存在的，这样是无法进行排序的</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">此时我们寻找办法，利用zip函数将字典的key，value进行对调，然后在对key进行排序，</span></span><br><span class="line"><span class="string">zip函数将字典的key，value分别封装成了一个元组，所有的元组组合成为一个列表，将此列表传入sorted函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a = zip(dict_a.values(), dict_a.keys())</span><br><span class="line">print(a)</span><br><span class="line">m = sorted(a, reverse=<span class="keyword">True</span>)<span class="comment"># 降序排列</span></span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">如果不使用zip函数将字典进行重新构造，我们可以使用匿名函数的方式，</span></span><br><span class="line"><span class="string">sorted(dict_a.items(), key=lambda x: x[1], reverse=True)，sorted函数的默认参数为：第一个参数传入要进行排序的可迭代对象，key=参数</span></span><br><span class="line"><span class="string">可以传入匿名函数进行处理，reverse参数决定升序还是降序排列。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a = sorted(dict_a.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="keyword">True</span>) <span class="comment"># key=需要传入一个函数，x[1]表示比较value，x[0]表示比较key，只有对比x[1]也就是value才可以进行排序</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本博客在于记录python高效编程之数据结构相关的编程技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;如何在列表、字典、集合中根据条件删选数据&quot;&gt;&lt;a href=&quot;#如何在列表、字典、集合中根据条件删选数据&quot; class=&quot;header
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python高效编程技巧" scheme="http://yoursite.com/tags/python%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>最新python面试题之数网络基础</title>
    <link href="http://yoursite.com/2018/01/18/%E6%9C%80%E6%96%B0python%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%95%B0%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/18/最新python面试题之数网络基础/</id>
    <published>2018-01-18T07:12:17.000Z</published>
    <updated>2018-01-22T10:18:21.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><blockquote><p>网络的基本知识</p></blockquote><hr><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>客户端通过向服务器发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数A。</li><li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应该为A+1，SYN/ACK包本身又有一个随机序号B。</li><li>最后，客户端再发送一个ACK。当服务端接受到这个ACK的时候，就完成了三路握手，并进入了链接创建状态。此时包序号被设定为收到的确认号A+1，而响应则为B+1.</li></ul><hr><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><blockquote><p>注意：中断连接可以是客户端，也可以是服务端。下面仅以客户端断开连接举例，反之亦然。</p></blockquote><ul><li>客户端发送一个数据分段，其中的FIN标记设置为1。客户端进入PIN-WAIT状态。该状态下的客户端只接收数据，而不再发送数据。</li><li>服务端当收到PIN=1的数据分段的时候，发送带有ACK=1的剩余的数据分段，来确认收到客户端发送过来的FIN信息。</li><li>服务器等到所有的数据传输服务结束之时，向客户端发送一个带有ACK=1的数据分段，并进入CLOSE-WAIT状态，等待客户端发来带有ACK=1的确认报文。</li><li>客户端收到服务器发来带有FIN=1的报文，返回ACK=1的报文确认，为了防止服务端未收到需要重发，进入TTIME-WAIT状态。服务器收到报文之后关闭连接。客户端等待2MSL后未收到答复；则认为服务器成功关闭，客户端关闭连接。</li></ul><p>图解：<a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p><hr><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>地址解析协议（Address Resolution Protocol），其基本的功能便是通过目标设备的ip地址，查询目标的MAC地址,以保证通信的顺利进行。她是IPv4网络层必不可少的协议，不过在IPv6中已经不再适用，并被邻居发现协议（NDP）所代替。</p><hr><h4 id="urllib和urllib2的区别"><a href="#urllib和urllib2的区别" class="headerlink" title="urllib和urllib2的区别"></a>urllib和urllib2的区别</h4><ul><li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这就是两者通常一块使用的原因。</li><li>urllib2可以接受一个Request类的实例来设置请求的headers，urllib仅可以接受URL。这意味着，你可以不用伪装你的User-Agent等。</li></ul><hr><h4 id="POS和GET"><a href="#POS和GET" class="headerlink" title="POS和GET"></a>POS和GET</h4><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener">知乎回答</a><br>get:<a href="https://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post:<a href="https://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p><hr><h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Cookie</th><th style="text-align:center">Session</th></tr></thead><tbody><tr><td style="text-align:center">存储位置</td><td style="text-align:center">客户端</td><td style="text-align:center">服务端</td></tr><tr><td style="text-align:center">目的</td><td style="text-align:center">跟踪会话，也可以保存用户的偏好设置或者保存用户的用户名密码等</td><td style="text-align:center">跟踪会话</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">不安全</td><td style="text-align:center">安全</td></tr></tbody></table><p>session的使用是需要cookie的支持的，之所以使用到session，主要是为了安全。</p><hr><h4 id="apache和nginx的区别"><a href="#apache和nginx的区别" class="headerlink" title="apache和nginx的区别"></a>apache和nginx的区别</h4><p>nginx相对apache的优缺点：</p><ul><li>轻量级，同样起web服务，比apache占用更少的内存及连接资源。</li><li>抗并发，nginx处理请求是异步非阻塞的，支持更多的并发连接，而apache则是阻塞型的，在高并发下nginx能保持低资源低消耗及高性能。</li><li>配置简洁。</li><li>高度模块化的设计，编写模块相对简单。</li><li>社区活跃。</li></ul><p>apache相对于nginx的优点：</p><ul><li>rewrite比nginx的rewrite强大。</li><li>模块超多，基本想到的都可以找到。</li><li>少bug，nginx的bug较多。</li><li>超稳定。</li></ul><hr><h4 id="网站用户密码的保存"><a href="#网站用户密码的保存" class="headerlink" title="网站用户密码的保存"></a>网站用户密码的保存</h4><ul><li>明文保存。</li><li>明文hash后保存，如md5。</li><li>md5+salt方式，这个salt可以随机。</li><li>知乎好像使用了Bcrypy加密。</li></ul><hr><h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">定义</th></tr></thead><tbody><tr><td style="text-align:center">1xx报告</td><td style="text-align:center">接收到请求，继续进程</td></tr><tr><td style="text-align:center">2xx报告</td><td style="text-align:center">步骤成功接收，被理解，并被接受</td></tr><tr><td style="text-align:center">3xx重定向</td><td style="text-align:center">为了完成请求必须采取进一步的措施</td></tr><tr><td style="text-align:center">4xx客户端出错</td><td style="text-align:center">请求顺序出错或者不能完成</td></tr><tr><td style="text-align:center">5xx服务端出错</td><td style="text-align:center">服务器无法完显然有效的请求</td></tr><tr><td style="text-align:center">403</td><td style="text-align:center">Forbidden</td></tr><tr><td style="text-align:center">404</td><td style="text-align:center">Not Found</td></tr></tbody></table><p>HTTPS握手，对称加密，非对称加密，TLS/SSH/RSA。</p><hr><h4 id="XSRF和XSS"><a href="#XSRF和XSS" class="headerlink" title="XSRF和XSS"></a>XSRF和XSS</h4><blockquote><p>跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。</p></blockquote><ul><li>CSRF(Cross-site request forgery)跨站请求伪造。<ul><li>举个例子：因为CSRF攻击利用的是冲着浏览器分不清发起请求是不是真正的用户本人。，也就是说，简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</li><li>用户Alice登录和访问某银行网站A，保留cookie。</li><li>Alice被某些信息诱导访问危险网站B。</li><li>危险网站B上有一个img标签。</li><li>这个标签的src不指向一张图片，而是一个http请求，这个请求向银行要求将Alice的1000元转给Badman，由于Alice的浏览器上有cookie，这样浏览器发出的这个请求就能得到响应执行。</li><li>这样Alice的钱就被偷了。</li></ul></li><li><p>XSRF防护（用户在浏览器中留下信息，浏览器对于接下来的操作是无法确定是不是用户本身的意愿）。所以防范的关键在于在请求中放入黑客所不能伪造的信息。从而防止黑客伪造一个完整的请求欺骗服务器。</p></li><li><p>XSS(Cross Site Scripting)跨站脚本攻击。</p><ul><li>XSS利用的是用户对目标网站的信任，而嵌入了恶意的脚本。</li></ul></li></ul><p>CSRF重点在请求,XSS重点在脚本</p><hr><h4 id="幂等-Idempotence"><a href="#幂等-Idempotence" class="headerlink" title="幂等 Idempotence"></a>幂等 Idempotence</h4><blockquote><p>这里针对HTTP的幂等性。<br>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用)</p></blockquote><ul><li>GET： 不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</li><li>DELETE： DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE <code>http://www.forum.com/article/4231</code>调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</li><li>POST： POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST <code>http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</li><li>PUT：PUT所对应的URI是要创建或更新的资源本身。比如：PUT <code>http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</li></ul><hr><h4 id="RESTful架构-SOAP-RPC"><a href="#RESTful架构-SOAP-RPC" class="headerlink" title="RESTful架构(SOAP,RPC)"></a>RESTful架构(SOAP,RPC)</h4><p>推荐阅读：<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p><hr><h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><blockquote><p>了解即可</p></blockquote><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><hr><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><blockquote><p>了解即可</p></blockquote><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p><p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了。</p><p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p><hr><h4 id="CGI和WSGI"><a href="#CGI和WSGI" class="headerlink" title="CGI和WSGI"></a>CGI和WSGI</h4><blockquote><p>了解即可</p></blockquote><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。 CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p><p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p><p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP-3333</a></p><hr><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><blockquote><p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p></blockquote><hr><h4 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h4><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐阅读：<a href="https://my.oschina.net/xianggao/blog/664275" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/664275</a></p><hr><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><blockquote><p>Socket=Ip address+ TCP/UDP + port</p></blockquote><p>推荐阅读：<a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p><hr><h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><p>推荐阅读： <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a><br>304 Not Modified</p><hr><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><blockquote><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;网络的基本知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次
      
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="python面试题" scheme="http://yoursite.com/tags/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>人人实验主站SEO现状、分析排查及提升方案</title>
    <link href="http://yoursite.com/2018/01/17/%E4%BA%BA%E4%BA%BA%E5%AE%9E%E9%AA%8C%E4%B8%BB%E7%AB%99SEO%E7%8E%B0%E7%8A%B6%E3%80%81%E5%88%86%E6%9E%90%E6%8E%92%E6%9F%A5%E5%8F%8A%E6%8F%90%E5%8D%87%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/01/17/人人实验主站SEO现状、分析排查及提升方案/</id>
    <published>2018-01-17T02:58:36.000Z</published>
    <updated>2018-01-22T06:49:24.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在分析主站在百度的Spider爬虫引擎的表现情况及结合现有可干预的技术手段，提升在百度的收录排名。（主要围绕百度检索引擎）</p></blockquote><h2 id="人人实验主站SEO现状"><a href="#人人实验主站SEO现状" class="headerlink" title="人人实验主站SEO现状"></a><a href="http://www.renrenlab.com" target="_blank" rel="noopener">人人实验</a>主站SEO现状</h2><h4 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a><a href="http://seo.chinaz.com/www.renrenlab.com" target="_blank" rel="noopener">站长工具</a></h4><p>通过站长工具可以得出大致信息如下：</p><ul><li><h5 id="网站的基本信息"><a href="#网站的基本信息" class="headerlink" title="网站的基本信息"></a>网站的基本信息</h5><img src="http://t1.aixinxi.net/o_1c412pk8pra07pr1do615qhag3a.png-j.jpg" alt=""><br>可以看到在百度的权重为<strong>2</strong>，百度的流量预计为<strong>159</strong>，在百度的关键词词库仅有<strong>1</strong>个关键词：<strong>实验</strong>。<br>在之前没做SEO前提下，在百度搜索引擎的表现较低；流量较小。</li></ul><hr><ul><li><h5 id="百度PC权重"><a href="#百度PC权重" class="headerlink" title="百度PC权重"></a>百度PC权重</h5><img src="http://t1.aixinxi.net/o_1c4137p4811mq1bi619f81psb1gaa.png-j.jpg" alt=""><br>关键字<strong>实验</strong>在百度的检索排名为第三；表现较好，唯一不足就是主站检索靠前的关键字太少；有且仅有一个<strong>实验</strong>。</li></ul><hr><ul><li><h5 id="百度移动权重"><a href="#百度移动权重" class="headerlink" title="百度移动权重"></a>百度移动权重</h5><img src="http://t1.aixinxi.net/o_1c413j7o8gsk1nji1c8218snncma.png-j.jpg" alt=""><br>移动权重暂时没有数据。<br>表现较差。</li></ul><hr><ul><li><h5 id="TDK收录情况"><a href="#TDK收录情况" class="headerlink" title="TDK收录情况"></a>TDK收录情况</h5><img src="http://t1.aixinxi.net/o_1c413detvq7177oq5nrdsk4a.png-j.jpg" alt=""><br>title：<strong>人人实验</strong><br>keywords：无<br>dec：无<br>表现较差。</li></ul><hr><ul><li><h5 id="百度权重的预估流量"><a href="#百度权重的预估流量" class="headerlink" title="百度权重的预估流量"></a>百度权重的预估流量</h5><img src="http://t1.aixinxi.net/o_1c413nb38il01uuu1ggb19m3j80a.png-j.jpg" alt=""><br>百度权重只要可以做到<strong>4</strong>或者<strong>5</strong>便可以带来非常可观的自然流量。</li></ul><hr><p>以上便是主站在百度Spider引擎的大致表现。</p><h4 id="主站模块收录情况"><a href="#主站模块收录情况" class="headerlink" title="主站模块收录情况"></a>主站模块收录情况</h4><blockquote><p>根据站内的导航栏大致将主站分为了8大模块，现依次进行说明</p></blockquote><ul><li><h5 id="首页模块"><a href="#首页模块" class="headerlink" title="首页模块"></a>首页模块</h5>现百度收录的页面主要也是集中在了首页的模块，具体的收录如图所示：<br><img src="http://t1.aixinxi.net/o_1c41bc4t8qltnp218ag1nll1st9a.png-j.jpg" alt=""><br>根据图示我们可以看到。收录的页面大致分为友情链接，以及底部的关于主站的介绍等。<br>因这些页面在首页的<strong>a</strong>标签中的<strong>href</strong>为静态链接，收录引擎对这些的收录较好。</li></ul><hr><ul><li><h5 id="服务机构模块"><a href="#服务机构模块" class="headerlink" title="服务机构模块"></a>服务机构模块</h5>服务机构模块共有504个列表页，3024个内容页，收录情况为<strong>0</strong>。<br><img src="http://t1.aixinxi.net/o_1c41bpq771lmn2v07p010vj1rfaa.png-j.jpg" alt=""><br>因其中的列表页与内容页的链接是以动态为主，百度的Spider对这些动态链接的收录十分的不友好，或者说是提取不到具体的静态的链接地址，也不知主站的url拼接规则，而导致。</li></ul><hr><ul><li><h5 id="服务大厅模块"><a href="#服务大厅模块" class="headerlink" title="服务大厅模块"></a>服务大厅模块</h5>服务大厅模块共有列表页394页，内容页3940页，收录的情况也为<strong>0</strong>。<br><img src="http://t1.aixinxi.net/o_1c41c5shs13g7keo1ni7ouk697a.png-j.jpg" alt=""><br>大致基本原因同服务机构模块。</li></ul><hr><ul><li><h5 id="仪器共享模块"><a href="#仪器共享模块" class="headerlink" title="仪器共享模块"></a>仪器共享模块</h5>仪器共享模块共有列表页14052页，内容页140520页，收录的情况也基本为<strong>0</strong>。<br><img src="http://t1.aixinxi.net/o_1c41cefrsi7r190214u61lccicna.png-j.jpg" alt=""><br>大致基本具体原因同上。</li></ul><hr><ul><li><h5 id="微需求模块"><a href="#微需求模块" class="headerlink" title="微需求模块"></a>微需求模块</h5><img src="http://t1.aixinxi.net/o_1c41ck8tm1m7mj0grei1ltj1aqpa.png-j.jpg" alt=""><br>相对来讲微需求模块需要被收录的优先级较低，但猜想是导航栏中跳转事件中没有实体的url导致。</li></ul><hr><ul><li><h5 id="创新券模块"><a href="#创新券模块" class="headerlink" title="创新券模块"></a>创新券模块</h5>创新券模块为静态页模块，百度应该已收录其中。<br><img src="http://t1.aixinxi.net/o_1c41d0o161nio6o111lp1felre3a.png-j.jpg" alt=""></li></ul><hr><ul><li><h5 id="科技头条模块"><a href="#科技头条模块" class="headerlink" title="科技头条模块"></a>科技头条模块</h5><blockquote><p>科技头条模块是主站每天都在更新的模块，活跃性较大，相对于百度Spider来说，更有倾向性，如果能把这个模块的SEO做好，相对于提升主站整体的SEO，会有较大的帮助。</p></blockquote></li></ul><p>但是科技头条同样存在页面非静态化的问题。<br><img src="http://t1.aixinxi.net/o_1c41djc5219hltd9105jak11lfha.png-j.jpg" alt=""><br>动态的url链接对收录蜘蛛不友好，基本未收录原同仪器共享模块。</p><hr><ul><li><h5 id="应用案例模块"><a href="#应用案例模块" class="headerlink" title="应用案例模块"></a>应用案例模块</h5><img src="http://t1.aixinxi.net/o_1c41eq74n4agtqudo1hcf4b8a.png-j.jpg" alt=""><br>基本未收录的情况同上。</li></ul><hr><h4 id="根据基本的SEO规则，对主站进行的SEO排查"><a href="#根据基本的SEO规则，对主站进行的SEO排查" class="headerlink" title="根据基本的SEO规则，对主站进行的SEO排查"></a>根据基本的SEO规则，对主站进行的SEO排查</h4><blockquote><p>详细情况见下表</p><ul><li>url：www.renrenlab.com/</li><li>√表示没有问题，×××表示存在问题，？为未知。</li></ul></blockquote><h5 id="域名类排查"><a href="#域名类排查" class="headerlink" title="域名类排查"></a>域名类排查</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">域名后缀</td><td style="text-align:center">√</td><td style="text-align:center">域名后缀是指代表一个域名类型的符号。 不同后缀的域名有不同的含义，现在最通俗的域名类别可分为国际域名、国内域名（包括中文和英文）、国外域名三类。</td><td style="text-align:center">目前使用的com域名，域名含义与品牌含义相关。</td></tr><tr><td style="text-align:center">注册时长</td><td style="text-align:center">√</td><td style="text-align:center">域名的注册时间有时可以判断这是否是一个钓鱼网站或者非法的网站的指标之一，注册时间越长的域名，更容易让搜索引擎喜欢</td><td style="text-align:center">renrenlab/域名年龄3年左右，较短</td></tr><tr><td style="text-align:center">是否被k过</td><td style="text-align:center">√</td><td style="text-align:center">一个域名被K后，即便改头换面也可能长期得不到搜索引擎有效的收录，被k过的域名续费大量时间进行恢复权重</td><td style="text-align:center">未k过</td></tr><tr><td style="text-align:center">注册商</td><td style="text-align:center">√</td><td style="text-align:center">域名注册商由互联网名称与数字地址分配机构（ICANN）或者一个国家性的国家代码顶级域名（ccTLD）域名注册局委派，以在指定的域名注册数据库中管理互联网域名，向公众提供此类服务；选择大型注册商有利于域名的安全</td><td style="text-align:center">阿里巴巴旗下阿里云。</td></tr><tr><td style="text-align:center">简短易记</td><td style="text-align:center">√</td><td style="text-align:center">贴近品牌，让人过目不忘</td><td style="text-align:center">域名就是品牌名</td></tr><tr><td style="text-align:center">whois</td><td style="text-align:center">√</td><td style="text-align:center">Whois是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商、域名注册日期和过期日期等）。通过域名Whois服务器查询，可以查询域名归属者联系方式。</td><td style="text-align:center">基本没有问题</td></tr><tr><td style="text-align:center">网站备案</td><td style="text-align:center">√</td><td style="text-align:center">网站备案是指向主管机关报告事由存案以备查考。行政法角度看备案，实践中主要是《立法法》和《法规规章备案条例》的规定。网站备案的目的就是为了防止在网上从事非法的网站经营活动，打击不良互联网信息的传播，如果网站不备案的话，很有可能被查处以后关停。</td><td style="text-align:center">京ICP备15058824</td></tr><tr><td style="text-align:center">BR</td><td style="text-align:center">xxx</td><td style="text-align:center">百度权重是爱站、站长工具等网站推出的针对网站关键词排名预计给网站带来流量，划分等级0-10的第三方网站欢迎度评估数据。百度权重并不是像谷歌的PR、搜狗的SR、IBM hits等那样的算法，是对网站的综合评级。百度权重只是针对关键词排名方面给网站带来的欢迎度进行评级。</td><td style="text-align:center">权重为2较低</td></tr><tr><td style="text-align:center">PR</td><td style="text-align:center">√</td><td style="text-align:center">PR值，即PageRank，网页的级别技术。取自Google的创始人Larry Page；它是Google排名运算法则（排名公式）的一部分，用来标识网页的等级/重要性。级别从0到10级，10级为满分。PR值越高说明该网页越受欢迎（越重要）。</td><td style="text-align:center">目前谷歌PR值已经很多没有进行过更新，暂时不需要优化。</td></tr><tr><td style="text-align:center">ALEXA</td><td style="text-align:center">√</td><td style="text-align:center">Alexa是一家专门发布网站世界排名的网站。以搜索引擎起家的Alexa创建于1996年4月（美国），目的是让互联网网友在分享虚拟世界资源的同时，更多地参与互联网资源的组织。</td><td style="text-align:center">目前很少有考核alexa排名的，所以暂时不用考虑</td></tr><tr><td style="text-align:center">链接提交</td><td style="text-align:center">xxx</td><td style="text-align:center">可以提交想被搜索引擎收录的链接，搜索引擎会按照标准处理，但不保证一定能够收录您提交的链接。</td><td style="text-align:center">可以整理出来全站栏目链接进行提交</td></tr><tr><td style="text-align:center">站点子链</td><td style="text-align:center">xxx</td><td style="text-align:center">每个站点下会开放一条或者多条主链，每个主链下支持提交6条以内的子链数据，支持对子链的排序和编辑</td><td style="text-align:center"><a href="http://zhanzhang.baidu.com/sitelink/index，人工添加子链" target="_blank" rel="noopener">http://zhanzhang.baidu.com/sitelink/index，人工添加子链</a></td></tr><tr><td style="text-align:center">二级域名</td><td style="text-align:center">xxx</td><td style="text-align:center">二级域名是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称；在国家顶级域名下，它是表示注册企业类别的符号。</td><td style="text-align:center">目前站点基本都是目录形式，可以考虑做几个二级域名的专题</td></tr><tr><td style="text-align:center">二级目录</td><td style="text-align:center">xxx</td><td style="text-align:center">二级目录，就是子目录，继承在主站目录下的，相当于在网站的根目录下再建立一个文件夹存放网站。</td><td style="text-align:center">目录太深</td></tr><tr><td style="text-align:center">HTTP状态查询</td><td style="text-align:center">√</td><td style="text-align:center">查询页面返回的状态,比如返回404表示页面不存在,返回500表示内部服务出错,返回301表示资源永久性跳转。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">HTTP/HTTPS属性</td><td style="text-align:center">√</td><td style="text-align:center">HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</td><td style="text-align:center">没有使用https</td></tr></tbody></table><hr><h5 id="服务器类排查"><a href="#服务器类排查" class="headerlink" title="服务器类排查"></a>服务器类排查</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">所在地区</td><td style="text-align:center">√</td><td style="text-align:center">服务器所在位置对网站的稳定性有极大影响。</td><td style="text-align:center">阿里云华北华南主机没问题</td></tr><tr><td style="text-align:center">IP</td><td style="text-align:center">√</td><td style="text-align:center">受过处罚的IP会导致网站权重降低或没有权重。</td><td style="text-align:center">ip干净</td></tr><tr><td style="text-align:center">服务器稳定性</td><td style="text-align:center">√</td><td style="text-align:center">服务器稳定是网站优化的前提。</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">避免使用免费主机</td><td style="text-align:center">√</td><td style="text-align:center">许多人选择免费虚拟主机搭建自己的网站或Web技术，事实上免费虚拟主机存在很大风险。免费主机不稳定并且会加入服务商广告。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">选择有信誉的主机提供商</td><td style="text-align:center">√</td><td style="text-align:center">保障服务器的安全与稳定。</td><td style="text-align:center">阿里云服务器，没有问题</td></tr></tbody></table><hr><h5 id="网站自身情况"><a href="#网站自身情况" class="headerlink" title="网站自身情况"></a>网站自身情况</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">收录</td><td style="text-align:center">xxx</td><td style="text-align:center">收录就是与互联网用户共享网址，网站收录前提是网站首页提交给搜索引擎，蜘蛛才会光顾，每次抓取网页时都会向索引中添加并更新新的网站，站长只需提供顶层网页即可，不必提交各个单独的网页。</td><td style="text-align:center">收录较少：27</td></tr><tr><td style="text-align:center">流量统计</td><td style="text-align:center">√</td><td style="text-align:center">网站流量统计是一种可以准确的分析访客用户的来源，便于网站管理者根据访客的需求增加或者修改网站的相关内容，便于更好的提升网站转换率，提高网站流量。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">友情链接</td><td style="text-align:center">√</td><td style="text-align:center">友情链接是指互相在自己的网站上放对方网站的链接。必须要能在网页代码中找到网址和网站名称，而且浏览网页的时候能显示网站名称，这样才叫友情链接。</td><td style="text-align:center">有友情链接板块</td></tr><tr><td style="text-align:center">发布外链</td><td style="text-align:center">?</td><td style="text-align:center">外链就是指在别的网站导入自己网站的链接。导入链接对于网站优化来说是非常重要的一个过程。导入链接的质量（即导入链接所在页面的权重）间接影响了我们的网站在搜索引擎中的权重。外链是互联网的血液，是链接的一种。没有链接的话，信息就是孤立的，结果就是我们什么都看不到。一个网站是很难做到面面俱到的，因此需要链接到别的网站，将其他网站所能补充的信息吸收过来，连接外链不在于数量，而是在于链接外链的质量。</td><td style="text-align:center">外链质量及数量无法确定</td></tr><tr><td style="text-align:center">购买外链</td><td style="text-align:center">?</td><td style="text-align:center">外链的作用同上，只不过友情链接、发布外链都没有购买外链的权重高，并且购买外链只要是按时续费，都会非常的稳定。</td><td style="text-align:center">目前没有采买任何外链</td></tr><tr><td style="text-align:center">模板</td><td style="text-align:center">√</td><td style="text-align:center">网站模板在这里指的是网站页面模板，是当网站中有许多页面版式色彩相同的情况下，将其定义为网页模板，并定义其中部分可编辑，部分不可利用网页模板制作其他页面时就会很方便，不易出错。</td><td style="text-align:center">暂时没有问题</td></tr><tr><td style="text-align:center">索引量</td><td style="text-align:center">√</td><td style="text-align:center">网站索引量，就是搜索引擎抓取层层筛选后选取的页面数量！站点内容页面需要经过搜索引擎的抓取和层层筛选后，方可在搜索结果中展现给用户。页面通过系统筛选，并被作为搜索候选结果的过程，即为建立索引。</td><td style="text-align:center">15W左右</td></tr><tr><td style="text-align:center">站内链接</td><td style="text-align:center">xxx</td><td style="text-align:center">站内链接也称内链，网站域名下的页面之间的互相链接,自己网站的内容链接到自己网站的内部页面，也称之为站内链接。1.网站内部之间的权重传递。2.推动网站页面的搜索引擎排名。3.提高蜘蛛对网站的索引效率，增加网站的收录。4.提高用户体验度，让访客留得更久。</td><td style="text-align:center">目前站内链接较少，可以手动进行内链设置，也可以写在程序中</td></tr><tr><td style="text-align:center">更新缓存</td><td style="text-align:center">?</td><td style="text-align:center">更新缓存是把现有的缓存文件清空，以便重新生成新的缓存文件。当管理员对网站数据进行了操作或者修改了模板，如果网站在显示方面未及时更新，就需要更新缓存。</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">批量提交（提交文章到搜索引擎）</td><td style="text-align:center">xxx</td><td style="text-align:center">可加快收录网址的速度 ，百度提供单条url提交通道，用户可提交想被收录的url网址</td><td style="text-align:center">没有提交</td></tr><tr><td style="text-align:center">robots.txt</td><td style="text-align:center">√</td><td style="text-align:center">robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">模拟抓取（模拟蜘蛛访问，看是否正常）</td><td style="text-align:center">xxx</td><td style="text-align:center">可以快速模拟搜索引擎蜘蛛访问页面所抓取到的内容信息，可以判断网站有没有被做跳转，否则影响SEO优化。</td><td style="text-align:center">没有模拟，动态页面不友好</td></tr><tr><td style="text-align:center">异地排名</td><td style="text-align:center">?</td><td style="text-align:center">快速了解网站关键词全国各地的排名情况，随时随地了解各地排名情况。</td><td style="text-align:center">异地排名未知</td></tr><tr><td style="text-align:center">死链</td><td style="text-align:center">√</td><td style="text-align:center">简单地讲，死链接指原来正常，后来失效的链接。死链接发送请求时，服务器返回404错误页面。1、动态链接在数据库不再支持的条件下，变成死链接。2、某个文件或网页移动了位置，导致指向它的链接变成死链接。3、网页内容更新并换成其他的链接，原来的链接变成死链接。4、网站服务器设置错误5、网站还没有完全做好，就上传到服务器上去了，这样也很多死链的。6、某文件夹名称修改，路径错误链接变成死链。</td><td style="text-align:center">不存在死链</td></tr><tr><td style="text-align:center">网站日志分析</td><td style="text-align:center">xxx</td><td style="text-align:center">网站日志是记录web服务器接收处理请求以及运行时错误等各种原始信息的以·log结尾的文件，确切的讲，应该是服务器日志。网站日志最大的意义是记录网站运营中比如空间的运营情况，被访问请求的记录。通过网站日志可以清楚的得知用户在什么IP、什么时间、用什么操作系统、什么浏览器、什么分辨率显示器的情况下访问了你网站的哪个页面，是否访问成功。</td><td style="text-align:center">需要导出网站日志文件，我们进行分析，看看蜘蛛的访问规律</td></tr><tr><td style="text-align:center">UV（独立访客）</td><td style="text-align:center">√</td><td style="text-align:center">UV（unique visitor）即独立访客数，指访问某个站点或点击某个网页的不同IP地址的人数。在同一天内，UV只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">IP（独立IP）</td><td style="text-align:center">√</td><td style="text-align:center">IP可以理解为独立IP的访问用户，指1天内使用不同IP地址的用户访问网站的数量，同一IP无论访问了几个页面，独立IP数均为1。但是假如说两台机器访问而使用的是同一个IP，那么只能算是一个IP的访问。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">日段分析</td><td style="text-align:center">√</td><td style="text-align:center">按天或是按周以及按月的搜索引擎来源分析，这对SEO非常的有帮助，能够最直接的站点哪些关键词带来了流量、哪些地区的访客多。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">周月分析</td><td style="text-align:center">√</td><td style="text-align:center">按天或是按周以及按月的搜索引擎来源分析，这对SEO非常的有帮助，能够最直接的站点哪些关键词带来了流量、哪些地区的访客多。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">来源搜索引擎统计</td><td style="text-align:center">xxx</td><td style="text-align:center">访客从哪个搜索引擎进入的网站</td><td style="text-align:center">未知</td></tr><tr><td style="text-align:center">来源关键词统计</td><td style="text-align:center">xxx</td><td style="text-align:center">访客在搜索引擎，通过什么关键词进入的网站</td><td style="text-align:center">未知，猜想为：人人实验</td></tr><tr><td style="text-align:center">着陆页统计</td><td style="text-align:center">√</td><td style="text-align:center">访客进入的网站页面如果用户体验不好，则会导致用户很快的离开网站，如果着陆页好则会产生转化。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">浏览深度</td><td style="text-align:center">√</td><td style="text-align:center">网站访问深度就是用户在一次浏览你的网站的过程中浏览了你的网站的页数。如果用户一次性的浏览了你的网站的页数越多，那么就基本上可以认定，你的网站有他感兴趣的东西。用户访问网站的深度用数据可以理解为网站平均访问的页面数，就是PV和UV的比值，这个比值越大，用户体验度越好，网站的粘性也越高。</td><td style="text-align:center">数极客统计</td></tr><tr><td style="text-align:center">国家/省份/城市分析</td><td style="text-align:center">xxx</td><td style="text-align:center">访客通过哪个国家、省份、城市进入的网站。</td><td style="text-align:center">不支持国外访问</td></tr></tbody></table><hr><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">域名/路径/文件名是否包含关键词</td><td style="text-align:center">√</td><td style="text-align:center">中文英文均可，让网站更加的人性化</td><td style="text-align:center">包含</td></tr><tr><td style="text-align:center">路径和文件名不能用中文</td><td style="text-align:center">√</td><td style="text-align:center">会被浏览器与搜索引擎自动转码，右侧是进入食品分类的链接规则，这根本没有任何规则可言，推荐使用伪静态进行设置。</td><td style="text-align:center">目前域名和文件名都是英文命名</td></tr><tr><td style="text-align:center">静态、动态</td><td style="text-align:center">xxx</td><td style="text-align:center">静态路径比动态路径有利于排名</td><td style="text-align:center">动态页面</td></tr><tr><td style="text-align:center">目录层级</td><td style="text-align:center">xxx</td><td style="text-align:center">目录不要超过四层</td><td style="text-align:center">目录有出现5层的页面</td></tr></tbody></table><hr><h5 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">密度</td><td style="text-align:center">?</td><td style="text-align:center">关键词密度（Keyword Density）与关键词频率（Keyword Frequency）所阐述的实质上是同一个概念，用来量度关键词在网页上出现的总次数与其他文字的比例，一般用百分比表示。相对于页面总字数而言，关键词出现的频率越高，关键词密度也就越大。</td><td style="text-align:center">关键词密度在1%-7%,尤以3%为优。本站密度未统计</td></tr><tr><td style="text-align:center">Title</td><td style="text-align:center">xxx</td><td style="text-align:center">Title，即一个网站的标题，通俗一点说就是一个网站的名字，是对一个网站主题内容的概括。一般而言，我们通过网站Title就能判断出这个网站到底是干什么的。对于一个SEO人员来讲，网站Title的写作十分重要，网站Title写作的成功与否直接关系到网站的流量多与少。</td><td style="text-align:center">90%以上页面没有</td></tr><tr><td style="text-align:center">Keywords</td><td style="text-align:center">xxx</td><td style="text-align:center">keywords网友访问是看不到的，通过查看源代码可以看到。主要作用是告诉搜索引擎，这个网站内容是什么。</td><td style="text-align:center">90%以上页面没有</td></tr><tr><td style="text-align:center">Description</td><td style="text-align:center">xxx</td><td style="text-align:center">description，网友在网页是不能直接看到的，查看源代码可以看到，功能让搜索引擎是判断整个页面内容的，当中要写入的内容是你页面内容的简介。</td><td style="text-align:center">90%以上页面没有</td></tr><tr><td style="text-align:center">H1至H6、B等标签</td><td style="text-align:center">xxx</td><td style="text-align:center">h1 - h6 标签可定义标题。h1 定义最大的标题。h6 定义最小的标题。由于 h 元素拥有确切的语义，因此请慎重地选择恰当的标签层级来构建文档的结构。因此，请不要利用标题标签来改变同一行中的字体大小。相反，我们应当使用层叠样式表定义来达到漂亮的显示效果。</td><td style="text-align:center">未规划</td></tr><tr><td style="text-align:center">关键词排名</td><td style="text-align:center">xxx</td><td style="text-align:center">关键词排名是一种在搜索引擎搜索结果中以字、词、词组的相关性体现网页排名的方式。可以分为关键词自然排名以及各搜索引擎提供的关键词竞价排名服务两种。是由利用长期总结出的搜索引擎收录和排名规则，关键词自然排名一般是搜索引擎对所有相关网页抓取结果自动分析、自动排名的体现，一般可以通过SEO优化技术来达到关键词排名提升。</td><td style="text-align:center">关键词：实验，百度排名第三，有且仅有一个可观的关键词</td></tr><tr><td style="text-align:center">长尾关键词</td><td style="text-align:center">xxx</td><td style="text-align:center">长尾关键词(Long Tail Keyword)是指网站上非目标关键词但也可以带来搜索流量的关键词。 长尾关键词的特征是比较长，往往是2-3个词组成，甚至是短语，存在于内容页面，除了内容页的标题，还存在于内容中。 搜索量非常少，并且不稳定。 长尾关键词带来的客户，转化为网站产品客户的概率比目标关键词高很多，因为长尾词的目的性更强。 存在大量长尾关键词的大中型网站，其带来的总流量非常大。例如，目标关键词是服装，其长尾关键词可以是男士服装、冬装、户外运动装等。长尾关键词基本属性是：可延伸性，针对性强，范围广。</td><td style="text-align:center">90%以上页面无</td></tr><tr><td style="text-align:center">核心关键词</td><td style="text-align:center">xxx</td><td style="text-align:center">核心关键词，指经过关键词分析确定下来的网站“核心”关键词，通俗地讲指，网站产品和服务的目标客户可能用来搜索的关键词。一般情况下，核心关键词具有这些特征：核心关键词一般作为网站首页的标题。核心关键词一般是2-4个字构成的一个词或词组，名词居多。核心关键词在搜索引擎每日都有一定数目的稳定搜索量。搜索核心关键词的用户往往对网站的产品和服务有需求，或者对网站的内容感兴趣。</td><td style="text-align:center">90%以上页面无</td></tr><tr><td style="text-align:center">地域关键词</td><td style="text-align:center">xxx</td><td style="text-align:center">地域性关键词就是高效的长尾关键词，这样的词都是转化率很高的词。</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">品牌关键词</td><td style="text-align:center">√</td><td style="text-align:center">不做赘述。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">敏感词管理</td><td style="text-align:center">√</td><td style="text-align:center">大部分论坛、网站等，为了方便管理，都进行了关于敏感词的设定。在多数网站，敏感词一般是指带有敏感政治倾向（或反执政党倾向）、暴力倾向、不健康色彩的词或不文明语，也有一些网站根据自身实际情况，设定一些只适用于本网站的特殊敏感词。</td><td style="text-align:center">没有问题</td></tr></tbody></table><hr><h5 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">图片 Alt 属性</td><td style="text-align:center">xxx</td><td style="text-align:center">图像的说明文本，在图片载入之前用于占位显示，在图片载入以后，以气泡提示方式显示。对图片搜索引擎也有重要意义，不同的浏览器对alt显示和处理方式有差异。</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">导出链接</td><td style="text-align:center">xxx</td><td style="text-align:center">导出链接就是网站或者页面中有指向别的网站的链接，是单向的。导出链接会导致网站的权重流向对方网站，PR还会传递到对方站，导出链接包括友情链接的交换和文章中的链接以及其他非本站的链接。</td><td style="text-align:center">极少</td></tr><tr><td style="text-align:center">网站地图</td><td style="text-align:center">xxx</td><td style="text-align:center">sitemap可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的sitemap形式，是以xml或txt文件进行提交，在其中列出网站中的网址以及关于每个网址的元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">首页突出重要内容</td><td style="text-align:center">√</td><td style="text-align:center">每个商家都有自己主推的产品，主推的产品在选择后要重点的进行优化，不仅要保证产品的质量与数量，还要保证在搜索引擎中的排名结果。</td><td style="text-align:center">产品在首页有展示</td></tr><tr><td style="text-align:center">Flash优化</td><td style="text-align:center">√</td><td style="text-align:center">因为FLASH优美的视觉效果和广阔的创意空间，FLASH技术在网页设计和网络广告中的应用非常广泛，很多网站首页甚至全部用 FLASH设计。但FLASH网页有一个非常致命的问题，即大部分搜索引擎无法识别 FLASH 中的信息。</td><td style="text-align:center">无flash</td></tr></tbody></table><hr><h5 id="网站内容"><a href="#网站内容" class="headerlink" title="网站内容"></a>网站内容</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">原创内容</td><td style="text-align:center">√</td><td style="text-align:center">原创内容较多，容易被众多网站引用，引用过程中一般都会给这个页面加链接，所以这个页面获得较好的评分，排名自然高。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">网站结构清晰明了</td><td style="text-align:center">√</td><td style="text-align:center">网站结构清晰明了，页面设计合理，既容易被用户浏览，也有利于搜索引擎蜘蛛爬行</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">每个页面小于100K</td><td style="text-align:center">√</td><td style="text-align:center">网页的大小直接决定访客需要等待的时候，如果一个网站页面打开时间超过3秒，57%的顾客会选择离开，这当中的80%的用户将不再访问。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">每个页面导出链接小于100个</td><td style="text-align:center">√</td><td style="text-align:center">导出链接过多会导致权重都传递到了其它网站，导致自己的网站没有了权重。</td><td style="text-align:center">最多6条没有问题</td></tr><tr><td style="text-align:center">突出关键词：大标题包含关键词</td><td style="text-align:center">xxx</td><td style="text-align:center">网页头部用h1注释的网页标题，包含关键词，比加黑更有效</td><td style="text-align:center">描述好title和h1标签</td></tr><tr><td style="text-align:center">突出关键词：颜色或黑体标注出</td><td style="text-align:center">xxx</td><td style="text-align:center">用B标签突出 或者用颜色突出</td><td style="text-align:center">相应的页面的关键词可以加粗</td></tr></tbody></table><hr><h5 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h5><table><thead><tr><th style="text-align:center">诊断项目</th><th style="text-align:center">诊断结果</th><th style="text-align:center">备注</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">JavaScript</td><td style="text-align:center">√</td><td style="text-align:center">JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">网站源码</td><td style="text-align:center">√</td><td style="text-align:center">网页访问速度的提升，是可以通过代码的优化来实现的。代码的优化，主要看代码的运行能力和执行效率，看其消耗CPU和内存的多少。</td><td style="text-align:center">没有问题</td></tr><tr><td style="text-align:center">页面编码</td><td style="text-align:center">√</td><td style="text-align:center">GBK、GB2312、UTF-8都是常见的网页编码，选择任意一个都可以。</td><td style="text-align:center">utf-8编码没问题</td></tr><tr><td style="text-align:center">GZIP压缩</td><td style="text-align:center">√</td><td style="text-align:center">gzip是HTML压缩算法的一种，HTTP压缩是在Web服务器和浏览器间传输压缩文本内容的方法。HTTP压缩工作原理是：Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩； 如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名； 如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件； 如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件； 如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件； 如果请求文件是ASPX等动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。</td><td style="text-align:center">没有问题</td></tr></tbody></table><hr><h4 id="SEO提升方案"><a href="#SEO提升方案" class="headerlink" title="SEO提升方案"></a>SEO提升方案</h4><blockquote><p>网站的SEO是一项综合性且长期性的工作；我们可以根据现有的规则尽量规避对Spider不友好的影响，但终究做好的话还需内外力共同影响。<br>主站在去年5月份全新改版，相对于老站来说是一个全新的网站；并且对于Spider讲，以前老站累计的爬虫索引全部作废会重新的进行收录（老主站的时间优势不复存在）。在今后的版本迭代中，尽可能的不要做大的体架的改动，利于SEO排名提升。</p></blockquote><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题!!"></a>存在的问题!!</h5><p>根据以上的分析及排查，从技术角度出发；主站现在主要存在的有下列问题：</p><ul><li><strong>静态化问题</strong><blockquote><p>主站现有的索引量大概在15W+左右，但是被百度收录的仅仅20几条；主要原因为页面非静态化，非静态的url和静态html百度Spider无法捕捉，或者说在主站这棵树形结构中提取不到符合Spider规则的页面内容。</p></blockquote></li></ul><ul><li>静态化的优势<ul><li>效率方面，访问html页面时，服务器找到页面后直接返回，不会再进行后台处理，速度快很多很多，同时也是解决高并发，降低服务器资源占用最有效的方式。各大门户类网站大家都可以看看页面的后缀，几乎都是.html结尾的。</li><li>seo方面，搜索引擎对html的收录较好，爬虫对html解析几乎是100%，而对动态页面则少之又少，静态化后页面收录会高N多倍。</li><li>网页的可控制性增强，网页的相似度降低。在将网页静态化的过程中，有机会定制静态网页的属性。比如url、标题、Title、KeyWord、Desciption等。通过增加这些网页元素的可控制性，我们可以降低网页的相似性，搜索引擎也会收录更多的网页。</li></ul></li><li>静态化的劣势<ul><li>纯静态的网页ReadOnly，失去了与用户的交互；网页功能性下降</li><li>且今后在做数据迁移时无法解析出结构化的数据。</li><li>需要投入较大精力维护，（例如：仪器信息修改了，就要重新生成一个新的html页面，即使只修改了一点点；大量操作对I/O不友好）</li><li>大量的静态网页增加维护的工作量。网站的更新改版是免不了的事。你可以试想一个有一万个网页的网站(并不是特别多)要在每个网页增加一些内容，这将会是一件非常麻烦的事情。当然你也许会说我程序写好一点，更新就会很方便。笔者承认编写优质高效的程序可以减少这样的工作量。但是没法彻底解决大量文件带来的麻烦。比如，很多静态化的网站都会有一个批量更新的功能。也就是批量生成静态网页。其实，这样的功能设计是很好的，但是在实际的使用中会出现一些问题。最大问题是由于各种软硬件原因，在数以万计的网页文件中，总是有极少数文件没有生成成功，更糟糕的是有些没生成成功的文件无法被记录下来，这些文件对于搜索引擎来说，可能会不太友好。</li><li>生成的静态网页消耗服务器资源。有很多开发者将生成的静态网页的功能是用线程完成的。当文件数量大时，这会很耗服务器资源。</li><li>生成静态网页会增加服务器空间的负担。我们可以进行一次估算：一篇文章的内容大概会占5K-10K，而其他的代码会占2/5-4/5，一个文件大概会增加15K左右，对于30万的文章数据库来说，需要增加了3.6G的硬盘空间使用。虽然现在的硬盘容量越来越大，但当网站的数据量达到一定的程度后，就得考虑这方面的因素了。</li></ul></li><li><p>伪静态技术</p><blockquote><p>为了兼顾静态页面优势以及动态页面优势，便出现了伪静态技术<br>伪静态是相对真实静态来讲的，通常我们为了增强搜索引擎的友好面，都将文章内容生成静态页面，但是有的朋友为了实时的显示一些信息。或者还想运用动态脚本解决一些问题。不能用静态的方式来展示网站内容。但是这就损失了对搜索引擎的友好面。怎么样在两者之间找个中间方法呢，这就产生了伪静态技术。就是展示出来的是以html一类的静态页面形式，但其实是用ASP一类的动态脚本来处理的。 </p></blockquote></li><li><p>伪静态技术优点</p><ul><li>避免动态页面对Spider的不友好，同时兼顾了动态页面需要的动态显示功能。</li></ul></li><li>伪静态技术的缺点<ul><li>网站承受力低。另外，会造成网站可承受同时在线人数剧减。如果你的网站可以保证1000人同时访问的话，那么做了伪静态处理之后，300人访问就足以让你网站挂掉。</li><li>网页打开慢。伪静态页面打开速度快，简直太搞笑了，伪静态仍然要读取数据库，还额外的多了一个.重写网址.的过程，其他的步骤绝对不会比动态少，怎么会快呢?</li><li>大量的重复页面。 做了伪静态后，原有的页面也可以访问，这就造成了大量的伪静态页面和动态页面重复，对网站极为不好。</li><li>需要服务器支持。并不是所有的服务器都支持伪静态的，这无形中又增加了成本。</li></ul></li><li><p>如何选择</p><ul><li>使用真静态和伪静态对SEO来说是否有区别？</li><li>使用真静态可能将导致硬盘损坏并将影响站点性能？</li><li>使用伪静态将占用一定量的CPU占有率，大量使用将导致CPU超负荷？</li><li>最重要的一点，我们要静态是为了SEO。</li><li>真静态的访问速度明显比伪静态的访问速度要高。</li></ul><blockquote><p>建议使用真静态技术，并且先对咨询模块进行静态化。</p></blockquote></li></ul><hr><ul><li>TDK问题<ul><li>主站的网页中缺少TDK营销，并且主站只有一个关键词：实验；排名较优，无其他关键词。</li><li>TDK中关键词较少，从搜索引擎进入主站的机会大大减小。</li></ul><hr></li><li>目录层级较深问题<ul><li>目录层级较深不利于Spider的检索，广度优先为主。</li></ul></li></ul><p><img src="http://t1.aixinxi.net/o_1c43q4ct81tscavkdq41p06hlga.png-j.jpg" alt=""></p><ul><li>无人工进行索引链接提交<blockquote><p>主动性不强</p></blockquote></li></ul><hr><ul><li>站点子链太少<blockquote><p>不利于主站树形结构建设</p></blockquote></li></ul><hr><ul><li>发布及购买外链质量及数量不理想<blockquote><p>外部曝光机会偏少</p></blockquote></li></ul><hr><ul><li>无来源搜索引擎及关键词统计<blockquote><p>无法有针对性的进行TDK营销</p></blockquote></li></ul><hr><ul><li>没有进行抓取模拟及网站日志分析<blockquote><p>尚且不知百度爬虫在主站的轨迹</p></blockquote></li></ul><hr><ul><li>图片Alt属性没有<blockquote><p>无法获取图片信息</p></blockquote></li></ul><hr><ul><li>网站地图不完善<blockquote><p>一定程度上无法确保Spider爬取的完整性</p></blockquote></li></ul><hr><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li>针对静态化<ul><li>需要将站内的url和页面转为静态化页面（大概涉及15w+左右）。</li><li>站内的首页导航栏及其他跳转链接也需转为静态url（大概涉及15w+左右）。</li><li>以上工作需后台与前端共同配合。</li></ul><hr></li><li>针对TDK<ul><li>做好TDK营销，保证每个页面有有针对性的TDK描述。（需运营配合）</li><li>进行keyword单页面密度规划，3%较优。</li><li>H1至H6、B等标签定义标题。</li><li>长尾关键词，根据页面内容生成针对性的长尾关键词，拓展范围及延伸性。</li><li>做好核心关键词的营销，确定核心关键词，为每个页面添加。</li><li>相应的做好地域关键词的营销，地域性关键词就是高效的长尾关键词，这样的词都是转化率很高的词。</li><li>做好TDK的突出，加粗标黑等方式。</li><li>英文逗号间隔关键词。</li><li>开发TDK后台编辑功能，随时可以对特定页面进行TDK编辑。</li></ul><hr></li><li><p>针对目录层级较深问题</p><blockquote><p>目录层级较深，说明后台后台目录文件层级结构区分清晰整洁，但也造成了对Spider不友好的一面</p></blockquote><ul><li>可以进行二级域名的申请，将较深的目录结构用二级域名代替。</li></ul></li></ul><hr><ul><li>针对网站地图，子链、外链、及统计搜索引擎关键词统计，可寻找相应的服务。</li></ul><hr><ul><li>针对网站的日志分析，爬虫的模拟，寻找Spider规律及访问数据分析。<ul><li>对主站日志做针对性的分析。寻找爬虫的到访轨迹及时间节点，做好网站的维护及更新。</li></ul></li></ul><h5 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h5><blockquote><p>主站整体的SEO的提升，需要将解决方案列为一个版本进行迭代，具体的措施步骤待和产品进行确定。<br>目标：希望通过SEO版本的迭代，在百度检索引擎中，关键词数量及关键词排名可以有较大幅度的提升。<br>静态化的技术科先从咨询板块开始进行尝试，咨询板块每天都有更新，对Spider十分的友好。</p></blockquote><hr><p>以上均为初步方案，待与产品确定具体的版本迭代细节，后期更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文旨在分析主站在百度的Spider爬虫引擎的表现情况及结合现有可干预的技术手段，提升在百度的收录排名。（主要围绕百度检索引擎）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;人人实验主站SEO现状&quot;&gt;&lt;a href=&quot;#人人实验主站SEO现
      
    
    </summary>
    
      <category term="SEO" scheme="http://yoursite.com/categories/SEO/"/>
    
    
      <category term="SEO" scheme="http://yoursite.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>最新python面试题之数据库</title>
    <link href="http://yoursite.com/2018/01/16/%E6%9C%80%E6%96%B0python%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/01/16/最新python面试题之数据库/</id>
    <published>2018-01-16T02:22:31.000Z</published>
    <updated>2018-01-22T10:18:11.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><blockquote><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li></ul></blockquote><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p><h4 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h4><p>推荐阅读：<a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">http://tech.meituan.com/mysql-index.html</a><br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a><br>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理。</p><h4 id="Redis原理"><a href="#Redis原理" class="headerlink" title="Redis原理"></a>Redis原理</h4><h5 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h5><ul><li>是一个完全开源免费的key-value内存数据库。</li><li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。</li></ul><p>Map结构</p><blockquote><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p></blockquote><h5 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h5><blockquote><p>通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作。</p></blockquote><ul><li>速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万。</li><li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)。</li><li>自动操作：对不同数据类型的操作都是自动的，很安全。</li><li>快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。</li><li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个物理节点上去的横向扩展方式用处越来越多。</li></ul><h5 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h5><ul><li>是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li></ul><p>乐观锁与悲观锁的具体区别: <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><blockquote><p>全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p></blockquote><p><a href="http://so.csdn.net/so/search/s.do?q=MySQL" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的<br>innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p><blockquote><ul><li>select：满足以下两个条件innodb会返回该行数据：<ul><li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li><li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li></ul></li><li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li><li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li><li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li></ul></blockquote><p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。<br>由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。<br>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p><blockquote><p>参考：<a href="http://blog.csdn.net/chosen0ne/article/details/18093187" target="_blank" rel="noopener">MVCC浅析</a></p></blockquote><h4 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h4><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><hr><p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><hr><p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h4&gt;&lt;h
      
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="python面试题" scheme="http://yoursite.com/tags/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最新python面试题之操作系统</title>
    <link href="http://yoursite.com/2018/01/10/%E6%9C%80%E6%96%B0python%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/01/10/最新python面试题之操作系统/</id>
    <published>2018-01-10T07:53:06.000Z</published>
    <updated>2018-01-22T10:17:58.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p>主要了解操作系统得相关的概念</p></blockquote><h4 id="select，poll和epoll"><a href="#select，poll和epoll" class="headerlink" title="select，poll和epoll"></a>select，poll和epoll</h4><blockquote><p>其实所有的I/O都是轮询的方法，只不过实现的层面不同罢了。</p></blockquote><p>这个问题可能有点深入了，但相信只要能答出这个问题的话是对I/O的多路复用有很好的了解的，其中tornado使用的就是epoll的。</p><blockquote><p>tornado是一种Web服务框架；关键是它和现在的主流的框架（包括Python的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当的快。得力于非阻塞方式和epoll的运用。Tornado每秒可以处理数以千计的连接，每一个活动用户都会保持着一个服务器连接。</p></blockquote><p>select，poll和epoll的区别和总结：<a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/p/3265058.html</a><br>基本上select有3个缺点：</p><ul><li>连接数受限。</li><li>查找配对的速度慢。</li><li>数据由内核拷贝到用户态。</li></ul><p>poll改善了第一个缺点。<br>epoll改了三个缺点。<br>很好的关于介绍epoll的：<a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="noopener">http://www.cnblogs.com/my_life/articles/3968782.html</a></p><hr><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><blockquote><ul><li>闲来先服务（FCFS, First Come First Serve）</li><li>短作业优先（SJF, Shortest Job First）</li><li>最高优先权调度（Priority Scheduling）</li><li>时间片轮转（RR, Round Robin）</li><li>多级反馈队列调度（multilevel feedback queue scheduling）</li></ul></blockquote><p>常见的调度算法的总结：<a href="https://www.jianshu.com/p/6edf8174c1eb" target="_blank" rel="noopener">https://www.jianshu.com/p/6edf8174c1eb</a></p><p>实时调度算法：</p><ul><li>最早截至时间优先 EDF</li><li>最低松弛度优先 LLF</li></ul><hr><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote><p>一般引起死锁的原因有：</p><ul><li>竞争资源</li><li>程序推进的顺序不当</li></ul></blockquote><p>必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul><p>处理死锁的基本方法</p><ul><li>预防死锁（摒弃除互斥条件以外的条件）</li><li>避免死锁（银行家算法）</li><li>检测死锁（资源分配图）</li><li>解除死锁<ul><li>剥夺资源</li><li>撤销进程</li></ul></li></ul><p> 死锁概念处理策略详细介绍：<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p><h4 id="程序编译与链接"><a href="#程序编译与链接" class="headerlink" title="程序编译与链接"></a>程序编译与链接</h4><p>推荐阅读：<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p><blockquote><p>Bulid过程可以分解为4个步骤：</p><ul><li>预处理（Prepressing）</li><li>编译（Compilation）</li><li>汇编（Assembly）</li><li>链接 （Linking）</li></ul></blockquote><p>以c语言为例：</p><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>预编译过程主要处理那些源文件中以“#”开始的预编译指令，主要的处理规则有：</p><ul><li>将所有的“#define”删除，并展开所用的宏定义</li><li>处理所有的条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#endif”</li><li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归执行的</li><li>删除所有的注释</li><li>添加行号和文件名的标识，以便于编译时编译器产生调试用的行号信息以及用于编译时编译错误或者警告时可显示的行号</li><li>保留所有的“#pragma”编译指令</li></ul><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>编译的过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的编译代码的文件。这个过程是整个程序构建的核心部分。</p><h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><p>汇编是将汇编代码转化成机器可以执行功的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件。</p><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。链接的主要过程包括地址和空间的分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等步骤。</p><h4 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h4><p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或者动态代码的地址确定下来，静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库。</p><p>动态链接方法：使用这种链接方法的程序，并不是在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算（被调用的那部分）动态代码的逻辑地址；然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以这种方式使程序在初始化的时间较短，但运行的性能比不上静态链接的程序。</p><h4 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h4><p>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑谁给你对内存容量加以扩充的一种存储系统。</p><h4 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h4><p>分页：用户程序的地址空间被划分成若干固定大小的区域，成为“页”，相应的，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。<br>分段：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对比较完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻，也实现了离散分配。</p><h5 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h5><p>1、页是信息的物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。段是信息的逻辑单位，它含有一组意义相对较完整的信息，分段的目的是为了更好的实现共享，满足用户的需要。<br>2、页的大小固定，是由系统来确定的，将逻辑地址划分为页号和页内地址是由机器硬件实现的，而段的长度确不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。<br>3、分页的作业地址的空间是一维的，分段的地址空间是二维的。</p><h4 id="页面置换算法（页面指内存分配）"><a href="#页面置换算法（页面指内存分配）" class="headerlink" title="页面置换算法（页面指内存分配）"></a>页面置换算法（页面指内存分配）</h4><p>1、最佳置换算法OPT:不可能实现<br>2、先进先出FIFO<br>3、最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换<br>4、clock算法</p><h4 id="边沿触发和水平触发"><a href="#边沿触发和水平触发" class="headerlink" title="边沿触发和水平触发"></a>边沿触发和水平触发</h4><p>边缘触发是指每当状态变化时发生一个io事件，水平触发是指只要满足条件就发生一个io事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要了解操作系统得相关的概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;select，p
      
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="python面试题" scheme="http://yoursite.com/tags/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最新python面试题之python特性</title>
    <link href="http://yoursite.com/2018/01/05/%E6%9C%80%E6%96%B0python%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bpython%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/05/最新python面试题之python特性/</id>
    <published>2018-01-05T05:15:25.000Z</published>
    <updated>2018-01-22T10:17:48.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python面试题"><a href="#Python面试题" class="headerlink" title="Python面试题"></a>Python面试题</h2><blockquote><p>关键在于了解Python的语言特性，结合具体的例子来理解Python的语言特性</p></blockquote><h4 id="python的函数参数传递"><a href="#python的函数参数传递" class="headerlink" title="python的函数参数传递"></a>python的函数参数传递</h4><p>看两个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">  a = 2</span><br><span class="line">fun(a)</span><br><span class="line">print a  # 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">def fun(a):</span><br><span class="line">  a.append(1)</span><br><span class="line">fun(a)</span><br><span class="line">print a  # [1]</span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看成是类似于c中void*的感觉。<br>上面的例子我们通过<code>id</code>来查看引用<code>a</code>的地址，来进行比较理解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">  print &quot;func_in&quot;,id(a)   # func_in 41322472</span><br><span class="line">  a = 2</span><br><span class="line">  print &quot;re-point&quot;,id(a), id(2)   # re-point 41322448 41322448</span><br><span class="line">print &quot;func_out&quot;,id(a), id(1)  # func_out 41322472 41322472</span><br><span class="line">fun(a)</span><br><span class="line">print a  # 1</span><br></pre></td></tr></table></figure></p><p>注：具体的id的值在不同的电脑上运行时可能有所不同，并且在Python中对较小的数字都进行了缓存。<br>可以看到，在执行完<code>a = 2</code>之后，a引用中保存的值，及内存地址发生了变化，由原来的<code>1</code>对象的地址变成了<code>2</code>这个实体对象的内存地址。<br>而在第2个例子<code>a</code>引用保存的内存地址就不会发生变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">def fun(a):</span><br><span class="line">  print &quot;func_in&quot;,id(a)  # func_in 53629256</span><br><span class="line">  a.append(1)</span><br><span class="line">print &quot;func_out&quot;,id(a)     # func_out 53629256</span><br><span class="line">fun(a)</span><br><span class="line">print a  # [1]</span><br></pre></td></tr></table></figure></p><p>在这里需要记住的是类型是属于对象的，而不是变量的。而对象有两种，“可更改”（mutable）和“不可更改的对象”（imnutable）。在Python中，string，tuples和numbers是不可更改的对象，而list，dict，set等则是可以修改的对象。（这就是这个问题的重点）</p><p>当一个引用传递给函数的时候，函数自动的复制一份引用，这个函数里的引用和外边的引用就没有半毛钱的关系了。所以第一个例子里函数把引用指向了一个不可变的对象，当函数返回的时候，外面的引用没半毛钱的感觉，而第二个例子不一样，函数内部引用指向的是可变对象，对它的操作就和定位了指针地址一样，在内存里直接的进行修改。</p><p>如果还不明白的话，这里有更好的解释： <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="noopener">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p><hr><h4 id="Python中的元类"><a href="#Python中的元类" class="headerlink" title="Python中的元类"></a>Python中的元类</h4><p>这个就非常的不常用了，但是像在ORM这种复杂的结构中还是会需要的，详情请看：:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p><hr><h4 id="staticmethod和-classmethod"><a href="#staticmethod和-classmethod" class="headerlink" title="@ staticmethod和@ classmethod"></a>@ staticmethod和@ classmethod</h4><p>Python中其实有3个方法，及静态方法（staticmethod），类方法（classmethod）和实例方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">  print&quot;executing foo(%s)&quot; % (x)</span><br><span class="line">class A(object):</span><br><span class="line">  def foo(self, x):</span><br><span class="line">    print(&quot;executing foo(%s,%s)&quot; % (self, x))</span><br><span class="line">  @classmethod</span><br><span class="line">  def class_foo(cls, x):</span><br><span class="line">    print(&quot;executing class_foo(%s,%s)&quot; % (cls, x))</span><br><span class="line">  @staticmethod</span><br><span class="line">  def static_foo(x):</span><br><span class="line">    print(&quot;executing static_foo(%s)&quot; % x)</span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure></p><p>这里先理解下函数参数里的self和cls。这个self和cls是对类或者实例的绑定，对于一般的函数来说我们可以这么的调用<code>foo(x)</code>，这个就是最常用的函数，它的工作跟任何的东西（类，实例）无关。对于实例方法，我们知道在类里每次定义方法的时候都需要绑定这个实例，就是<code>foo(self,x)</code>，为什么要这么做呢？因为实例方法的调用离不开实例，我们需要把实例自己传递给函数，调用的时候是这样的<code>a.foo(x)</code>（其实是<code>foo(a,x)</code>）。类方法一样，只不过它传递的是类而不是实例，<code>A.class_foo(x)</code>。注意这里的self和cls可以替换成别的参数，但是Python中的约定是这俩，还是不要改的好。<br>对于静态方法其实和普通的方法一样，不需要对谁进行绑定，唯一的区别就是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来进行调用。<br>下面是一张表格，来比对各种方法的可以的调用形式</p><table><thead><tr><th style="text-align:center">\</th><th style="text-align:center">实例方法</th><th style="text-align:center">类方法</th><th style="text-align:center">静态方法</th></tr></thead><tbody><tr><td style="text-align:center">a = A()</td><td style="text-align:center">a.foo(x)</td><td style="text-align:center">a.class_foo(x)</td><td style="text-align:center">a.static_foo(x)</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">不可用</td><td style="text-align:center">A.class_foo(x)</td><td style="text-align:center">A.static_foo(x)</td></tr></tbody></table><p>更度多的关于这个问题：<br>1.<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a><br>2.<a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></p><hr><h4 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h4><h5 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h5><blockquote><p>是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance就是类变量，用于跟踪存在着多少个Test的实例。</p></blockquote><h5 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h5><blockquote><p>实例化之后，每个实例单独拥有的变量</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">  um_of_instance = 0</span><br><span class="line">  def __init__(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line">    Test.num_of_instance += 1</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print est.num_of_instance  # 0</span><br><span class="line">    t1 = Test(&apos;jack&apos;)</span><br><span class="line">    print est.num_of_instance  # 1</span><br><span class="line">    t2 = Test(&apos;lucy&apos;)</span><br><span class="line">    print t1.name, t1.num_of_instance  # jack 2</span><br><span class="line">    print t2.name.num_of_instance  # lucy 2</span><br></pre></td></tr></table></figure><blockquote><p>补充的例子</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">  name=&quot;aaa&quot;</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=&quot;bbb&quot;</span><br><span class="line">print p1.name  # bbb</span><br><span class="line">print p2.name  # aaa</span><br><span class="line">print Person.name  # aaa</span><br></pre></td></tr></table></figure><p>这里的<code>p1.name=&#39;bbb&#39;</code>是实例调用了类变量，这其实和上面的第一个问题一样，就是函数传参的问题，<code>p1.name</code>一开始是指向的类变量<code>name=&#39;aaa&#39;</code>，但是在实例的作用域里把类变量的引用改变了，就变成了一个实例变量，self.name不再引用Person的类变量name了。<br>可以看看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">  name=[]</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(1)</span><br><span class="line">print p1.name  # [1]</span><br><span class="line">print p2.name  # [1]</span><br><span class="line">print Person.name  # [1]</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p><hr><h4 id="Python的自省"><a href="#Python的自省" class="headerlink" title="Python的自省"></a>Python的自省</h4><p>这个也是Python彪悍的特性。<br>自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单一句就是运行时能够捕获到对象的类型。比如type()，dir()（返回当前模块的属性列表)，getattr(返回对象的属性)，setattr()（动态添加属性）这两者参考set，get方法，hasattr()（判断是否包含哪个属性），isinstance()（判断对象是否属于哪个类型）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = &#123;&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3&#125;</span><br><span class="line">c = True</span><br><span class="line">print type(a),type(b),type(c) # &lt;type &apos;list&apos;&gt; &lt;type &apos;dict&apos;&gt; &lt;type &apos;bool&apos;&gt;</span><br><span class="line">print isinstance(a,list)  # True</span><br></pre></td></tr></table></figure></p><hr><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p>可能你见过列表推导式，却没有见过字典推导式，在2.7中才加入的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key: value for (key, value) in iterable&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="Python中单下划线和双下划线"><a href="#Python中单下划线和双下划线" class="headerlink" title="Python中单下划线和双下划线"></a>Python中单下划线和双下划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyClass():</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...             self.__superprivate = &quot;Hello&quot;</span><br><span class="line">...             self._semiprivate = &quot;, world!&quot;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; mc = MyClass()</span><br><span class="line">&gt;&gt;&gt; print mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute &apos;__superprivate&apos;</span><br><span class="line">&gt;&gt;&gt; print mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line">&gt;&gt;&gt; print mc.__dict__</span><br><span class="line">&#123;&apos;_MyClass__superprivate&apos;: &apos;Hello&apos;, &apos;_semiprivate&apos;: &apos;, world!&apos;&#125;</span><br></pre></td></tr></table></figure><p><code>__foo__</code>：一种约定，Python内部的名字，用来区别其他用户自定义的命名，以防冲突么就是例如：<code>__init__(),__del__(),__calll__()</code>这些的特殊的方法。<br><code>_foo</code>：一种约定，用来指定变量私有，程序员用来指定私有变量的一种方式，不能用<code>from module impore*</code>导入，其他的方面和公有一样访问。<br><code>__foo</code>：这个有真正的意义：解析器用<code>_classname__foo</code>来代替这个名字，以区别和其他类相同的命名，它无法直接像公有成员一样随便访问，通过<code>对象名._类名__xxx</code>这样的方式访问。<br>详情见：<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a><br>或者：<a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p><hr><h4 id="字符串格式化：-和-format"><a href="#字符串格式化：-和-format" class="headerlink" title="字符串格式化：%和.format"></a>字符串格式化：%和.format</h4><p>.format在许多发面看起来会更加的便利，对于%最烦人的是它无法同时传递一个变量和元组。你可能会想下面的代码不会有什么问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % name</span><br></pre></td></tr></table></figure></p><p>但是，如果name恰好是(1,2,3)，那么它将会跑出一个TypeError异常，为了保证它是正常的，你必须这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></table></figure></p><p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.<br>你为什么不用它？</p><ul><li>不知道它（在读这个之前）</li><li>为了和Python2.5兼容（譬如logging库建议使用<code>%</code>）</li></ul><p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="noopener">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p><hr><h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a><br>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a><br>这里有个关于生成器的创建问题面试官有考： 问： 将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x*x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x*x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt;</span><br></pre></td></tr></table></figure></p><p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</p><hr><h4 id="args-and-kwargs"><a href="#args-and-kwargs" class="headerlink" title="*args and **kwargs"></a>*args and **kwargs</h4><p>用*args和*<em>kwargs只是为了方便并没有强制使用它们。<br>当你不确定你的函数里将要传递多少参数时你可以用*</em>args.例如,它可以传递任意数量的参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_everything(*args):</span><br><span class="line">        for count, thing in enumerate(args):</span><br><span class="line">...         print &apos;&#123;0&#125;. &#123;1&#125;&apos;.format(count, thing)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;)</span><br><span class="line">0. apple</span><br><span class="line">1. banana</span><br><span class="line">2. cabbage</span><br></pre></td></tr></table></figure></p><p>相似的,**kwargs允许你使用没有事先定义的参数名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def table_things(**kwargs):</span><br><span class="line">...     for name, value in kwargs.items():</span><br><span class="line">...         print &apos;&#123;0&#125; = &#123;1&#125;&apos;.format(name, value)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure></p><p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.</span><br></pre></td></tr></table></figure><p>当调用函数时你也可以用*和**语法.例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_three_things(a, b, c):</span><br><span class="line">...     print &apos;a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;&apos;.format(a,b,c)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; mylist = [&apos;aardvark&apos;, &apos;baboon&apos;, &apos;cat&apos;]</span><br><span class="line">&gt;&gt;&gt; print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure></p><p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.<br><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="noopener">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p><hr><h4 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h4><p>这个AOP一听起来有点懵，下面做下解释；Java的spring框架中有OOP编程，而AOP可以看成是OOP的补充。</p><blockquote><p>面向切面编程（AOP是Aspect Oriented Program的缩写），我们知道，面向对象的特点是继承<br>多态和封装。而封装就是将不同的功能分散到不同的对象中去，这种设计往往在软件设计中叫做职责分配。实际上就是说让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处就是降低了代码的复杂程度，使类可以重用。<br>但是人们发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？就是比如说，我们两个类中，可能都需要在每个方法上做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入写日志的内容。即使写日志的代码都相同；但就是因为面向对象的设计方法让类与类之间是无法联系的，而不能将这些代码统一起来。<br>也许会有人说，那好办呐，我们可以将写日志的这段代码写在一个独立类的方法里，然后在这两个类中调用。但是这样一来，这两个类跟我们上面提到的独立的类就有耦合了，他的改变会影响到这两个类。（这里就是耦合的弊端）有什么解决办法呢？能让我们在需要的时候随意的插入功能代码？<br><strong>这种在运行时，动态的将特定的功能代码将入到（切入到）类的指定的方法、指定位置上的编程思想就是面向切面的编程</strong><br>一般而言，我们管切入到指定类的指定方法的代码片段称之为切面，而切入到哪些类，哪些方法则叫做切入点。有了AOP，我们就可以将几个类共有的功能代码，抽取到一个切面中，等到需要的时候再切入到对象中去，从而改变其原有的行为。<br>这样看来，AOP其实是OOP的补充而已。OOP从横向的区分出一个个类来，而AOP则从纵向上像对象中加入特定的代码。有了AOP，OOP就变的立体了。如果加上时间的纬度，AOP使OOP有原来的二位变为了三维，有平面变成了立体。从技术上说AOP基本上是通过代码机制实现的。<br>AOP在编程历史上可以说是里程碑式的，对OOP是一种补充。</p></blockquote><p>而在Python中面向切面编程便是Python中的语法糖装饰器。装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有日志的插入，性能的测试、事物的处理等。装饰器是解决这类问题的绝佳的设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同的代码并可以继续的重用。概括的讲装饰器的作用就是为已经存在的对象添加额外的功能。<br>这个问题比较大，推荐：<a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a><br>中文：<a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p><hr><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>“当你看到一张鸟走起来像鸭子，游起泳来像鸭子、叫起来也像鸭子，那么可以称这只鸟为鸭子”。</p><blockquote><p>我们并不关心对象是什么类型（到底是不是鸭子），我们只关心它的行为。<br>鸭子类型的使用，经常出现在动态语言中，非常的灵活。<br>比如在Python中，有很多file-like的东西，比如StringIO，GzipFile，socket。他们有很多相同的方法，我们把它们当做文件使用。<br>又比如：list.extend()，我们不关心它的参数是不是list，只要它是可迭代的，所以它的参数可以是list/tuple/dict/字符串/生成器等。<br>这样使得Python不像java那样专门去弄一大推的设计模式。</p></blockquote><hr><h4 id="Python中的重载"><a href="#Python中的重载" class="headerlink" title="Python中的重载"></a>Python中的重载</h4><blockquote><p>Python中其实不需要做函数的重载</p></blockquote><p>函数的重载主要是为了解决两个问题。</p><ul><li>可变参数类型</li><li>可变参数个数</li></ul><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型个参数个数不同以外，其功能是完全的相同的，此时才需要用到函数的重载，如果两个函数的功能本来就是不同的，那么就不应当使用重载，而应当使用一个名字不同的函数。<br>好吧，那么对于情况1，函数功能相同，但是参数的类型不同，Python如何的处理？答案是根本不需要处理，因为Python可以接收任何类型的参数，如果函数的功能相同，那么不同的参数类型在Python中很可能是相同的代码，则没有必要做成两个函数。<br>那么对于情况2，函数功能相同，但是函数的参数个数不同，Python如何处理？大家都知道，那就是缺省参数。对于那些缺少的参数将其设定为缺省参数即可解决问题。因为你假设函数的功能相同，那么那些缺少的参数最终还是需要用到的。<br>好了，鉴于情况1更情况2都有了解决方案，Python自然就不需要进行函数的重载了。</p><hr><h4 id="新式类和旧式类"><a href="#新式类和旧式类" class="headerlink" title="新式类和旧式类"></a>新式类和旧式类</h4><blockquote><p>提前说明一下，新式类的查找顺序是广度优先，而旧式类的查找顺序是深度优先</p></blockquote><p>这里有一篇文藏很好的介绍了新式类的特性：<a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="noopener">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a><br>新式类很在在2.2中就已经出现了，所以旧式类则完全沦为了兼容的问题，Python3里的类全部都是新式类。这里有一个MRO问题可以了解一下（新式类是广度优先，旧式类是深度优先）</p><blockquote><p>一个旧式类的深度优先的例子</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A():</span><br><span class="line">    def foo1(self):</span><br><span class="line">        print &quot;A&quot;</span><br><span class="line">class B(A):</span><br><span class="line">    def foo2(self):</span><br><span class="line">        pass</span><br><span class="line">class C(A):</span><br><span class="line">    def foo1(self):</span><br><span class="line">        print &quot;C&quot;</span><br><span class="line">class D(B, C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo1()</span><br><span class="line"></span><br><span class="line"># A</span><br></pre></td></tr></table></figure><p>按照经典的查找顺序，从做到右深度优先的原则，在访问<code>d.foo1()</code>的时候，D这个类是没有具体的实现的，那么往上查找，先找到B，B里面也没有，深度优先访问到A，找到了<code>foo1()</code>所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过。</p><hr><h4 id="new和init的区别"><a href="#new和init的区别" class="headerlink" title="new和init的区别"></a><strong>new</strong>和<strong>init</strong>的区别</h4><blockquote><p><code>__new__返回个一个cls的静态实例</code>，只有当返回cls的静态实例后<code>__init__</code>才会被调用<br>实际上就是一个调用先后的问题，一般不用重写<code>__new__</code>。</p></blockquote><ul><li><code>__new__</code>是一个静态方法，而<code>__init__</code>是一个实例方法。</li><li><code>__new__</code>方法返回一个创建的实例，而<code>__init__</code>什么都不返回。</li><li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才被调用。</li><li>当创建一个新的实例时调用<code>__new__</code>，初始化一个实例时用<code>__init__</code>。</li></ul><p><a href="https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new" target="_blank" rel="noopener">stackoverflow</a><br>ps：<code>__metaclass__</code>是创建类是起作用，所以我们分别使用<code>__metaclass__</code>，<code>__new__</code>和<code>__init__</code>来分别在在类创建，实例创建和实例初始化的时候做一些小的手脚。</p><hr><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote><p>单例模式是一种软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例的模式保证系统中一个类之后一个实例而且该实例易于被外界访问。从而方便对实例的个数控制并节省系统得资源。如果希望在系统中的某个类的对象只能存在一个，单例模式是最好的解决方案。<br><code>__new__</code>在<code>__init__</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可是实现设计模式的单例模式。单例模式是指创建唯一的对象，单例模式的类只能实例。</p></blockquote><p>一下介绍几种方法：</p><ul><li>使用<code>__new__</code>方法结合共享属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        if not hasattr(cls, &apos;_instance&apos;):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><ul><li>共享属性</li></ul><p>创建实例时把所有的<code>__dict__</code>指向同一个字典，这样他们就具有了相同的属性和方法，具有了相同的属性和方法Python中就不需要进行重载，它们本省就是同一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Borg(object):</span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        return ob</span><br><span class="line"></span><br><span class="line">class MyClass2(Borg):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure></p><ul><li>装饰器版本的共享属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls, *args, **kw):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    def getinstance():</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    return getinstance</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class MyClass:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ul><li>import方法</li></ul><p>作为Python的模块是天然的单例模式，当然要选择合适的应用场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"># to use</span><br><span class="line">from mysingleton import my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure></p><hr><h4 id="Python中的作用域"><a href="#Python中的作用域" class="headerlink" title="Python中的作用域"></a>Python中的作用域</h4><blockquote><p>Python中，一个变量的作用域总是在代码中被赋值的地方所决定的。</p></blockquote><p>当Python遇到一个变量的话他会按照这样的顺序进行搜索：<br>本地作用域（Local）-&gt;当前作用域被嵌入的本地作用域（Enclosing locals）-&gt;全局/模块作用域-&gt;内置作用域（Built-in）</p><hr><h4 id="GIL线程全局锁"><a href="#GIL线程全局锁" class="headerlink" title="GIL线程全局锁"></a>GIL线程全局锁</h4><blockquote><p>GIL是针对Python下的多线程来讲的</p></blockquote><p>线程全局锁（Global Interpreter Lock），即Python为了保证线程安全而采取的独立线程运行的限制，说白了就是一个核只能在同一时间运行一个线程。对于IO密集型任务，Python的所线程可以起到作用，但对于CPU密集型任务，Python的多线程几乎占不到任何的优势，还有可能会因为资源的争夺而变慢。<br>详细见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python最难的问题</a><br>解决办法就是多进程和下面的协程（协程也只是单CPU，但是能减小切换代价提升性能）。</p><hr><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><blockquote><p>简单点说协程是进程和线程的升级版</p></blockquote><p>进程和线程都面临着内核态和用户态的切换问题而耗费许多的切换的时间，而协程就是用户自己控制切换的时机，不再需要陷入系统得内核态。<br>Python里最常见的yiled就是协程的思想！</p><hr><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote><p>闭包（closure）是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p></blockquote><p>当一个内嵌函数引用其外部作用域的变量，我们就会得到一个闭包，总结一下创建一个闭包必须满足以下几点：</p><ul><li>必须要有一个内嵌的函数。</li><li>内嵌函数必须引用外部函数中的变量。</li><li>外部函数的返回值必须是内嵌函数。</li></ul><p>感觉闭包还是有难度的，几句话是说不明白的，还是查查相关的资料吧。<br>重点是函数运行之后并不会被撤销，就像上面的单例模式中的装饰器方法中的instance字典一样，当函数运行完之后，instance并不销毁，而是继续保存在内存空间里。这个功能类似类里的类变量，只不过迁移到了函数上。<br>闭包就像个空心球一样，你知道外面和里面，但你不知道中间是什么样的。</p><hr><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><blockquote><p>其实就是一个匿名的函数，为什么引入lambda，是为了函数式编程不用再去重新定义小功能的函数</p></blockquote><p>推荐阅读：<a href="https://www.zhihu.com/question/20125256" target="_blank" rel="noopener">知乎</a></p><hr><h4 id="Python函数式编程"><a href="#Python函数式编程" class="headerlink" title="Python函数式编程"></a>Python函数式编程</h4><blockquote><p>Python中函数式编程主要用到的高阶函数有filter，map，reduce和列表及字典解析，将它们嵌套lambda使用。</p></blockquote><p>推荐阅读： <a href="https://coolshell.cn/articles/10822.html" target="_blank" rel="noopener">酷壳</a><br>Python中函数式编程的支持：</p><ul><li>fliter函数</li></ul><p>filter函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来遍历每个可迭代集合中的每一个对象，返回一个使<code>bool_seq</code>返回值为true的元素序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3,4,5,6,7]</span><br><span class="line">&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)</span><br><span class="line">&gt;&gt;&gt;print b</span><br><span class="line">&gt;&gt;&gt;[6,7]</span><br></pre></td></tr></table></figure></p><ul><li>map函数</li></ul><p>map函数是对一个序列的每个项依次执行定义好的函数，下面是对序列的每一项都乘以2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])</span><br><span class="line">&gt;&gt;&gt; list(a)</span><br><span class="line">[2, 4, 6]</span><br></pre></td></tr></table></figure></p><ul><li>reduce函数</li></ul><p>reduce函数是对一个序列的每个项迭代调用函数。下面是求3的阶乘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><hr><h4 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h4><blockquote><p>Python里的拷贝分浅拷贝和深拷贝，浅拷贝不追踪对象的时间维度节点，深拷贝始终追踪对象的时间维度节点。</p></blockquote><p>在这里引用copy()，deepcopy()的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]  #原始对象</span><br><span class="line"></span><br><span class="line">b = a  #赋值，传对象的引用</span><br><span class="line">c = copy.copy(a)  #对象拷贝，浅拷贝</span><br><span class="line">d = copy.deepcopy(a)  #对象拷贝，深拷贝</span><br><span class="line"></span><br><span class="line">a.append(5)  #修改对象a</span><br><span class="line">a[4].append(&apos;c&apos;)  #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象</span><br><span class="line"></span><br><span class="line">print &apos;a = &apos;, a</span><br><span class="line">print &apos;b = &apos;, b</span><br><span class="line">print &apos;c = &apos;, c</span><br><span class="line">print &apos;d = &apos;, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line">b =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line">c =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br><span class="line">d =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]</span><br></pre></td></tr></table></figure></p><hr><h4 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h4><blockquote><p> Python GC主要使用引用计数（reference counting）来追踪和回收垃圾。在引用计数的基础上。通过“标记”和“清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收的效率。</p></blockquote><ul><li>引用计数</li></ul><p>PyObject是每个对象必有的内容。其中<code>ob_refcnt</code>就是作为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象删除时，它的<code>ob_refcnt</code>就会减少，当引用的计数为0时，该对象的生命就结束了。</p><p>优点：<br>1、简单。<br>2、实时性。</p><p>缺点：<br>1、维护引用计数消耗资源。<br>2、循环引用。</p><ul><li>标记-清除机制</li></ul><p>基本的思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点，以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没有标记的对象释放。</p><ul><li>分代技术</li></ul><p>分代回收的整体思想是：将系统中的所有内存块根据其存活的时间划分为不同的集合，每个集合就成为了一个“代”，垃圾的收集频率随着“代”的存活的时间的增大而减小，存活的时间通常利用经过几次垃圾回收来度量。</p><p>Python默认定义了三代对象集合，索引数越大，对象的存活时间就越长。</p><p>举例：当某些内存块M经过了3次垃圾收集的清洗后如果还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集的工作开始时，大多数的情况就只针对B集合进行垃圾回收，而对集合A进行垃圾回收要间隔相当长的一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，回收工作本身占用的系统资源减少，效率自然就提高了。这这个过程中，集合B中的某些内存块由于存活时间较长而被转移到集合A中，当然，集合A中实际上也会存在一些的垃圾，这些垃圾的回收会因为这种分代的机制而被延迟回收。</p><hr><h4 id="Python的List"><a href="#Python的List" class="headerlink" title="Python的List"></a>Python的List</h4><p>推荐阅读：<a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="noopener">http://www.jianshu.com/p/J4U6rR</a></p><hr><h4 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h4><p>is是对比地址，==是对比值。</p><hr><h4 id="read，readline和readlines"><a href="#read，readline和readlines" class="headerlink" title="read，readline和readlines"></a>read，readline和readlines</h4><blockquote><p>read 读取整个文件<br>readline 读取下一行，使用生成器的方法<br>readlines 读取整个文件到一个迭代器以供我们遍历</p></blockquote><hr><h4 id="Python2和3的区别"><a href="#Python2和3的区别" class="headerlink" title="Python2和3的区别"></a>Python2和3的区别</h4><p>推荐阅读：Python 2.7.x 与 Python 3.x 的主要差异</p><hr><h4 id="super-init"><a href="#super-init" class="headerlink" title="super init"></a>super init</h4><p>super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already.</p><p>Note that the syntax changed in Python 3.0: you can just say super().<strong>init</strong>() instead of super(ChildB, self).<strong>init</strong>() which IMO is quite a bit nicer.</p><p><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods" target="_blank" rel="noopener">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a></p><p><a href="http://blog.csdn.net/mrlevo520/article/details/51712440" target="_blank" rel="noopener">Python2.7中的super方法浅见</a></p><hr><h4 id="range-and-xrange"><a href="#range-and-xrange" class="headerlink" title="range and xrange"></a>range and xrange</h4><p>都是在循环的时候使用，xrange内存的性能更好。for i in range(0, 20): for i in xrange(0, 20): What is the difference between range and xrange functions in Python 2.X? range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. xrange is a sequence object that evaluates lazily.</p><p><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x" target="_blank" rel="noopener">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python面试题&quot;&gt;&lt;a href=&quot;#Python面试题&quot; class=&quot;headerlink&quot; title=&quot;Python面试题&quot;&gt;&lt;/a&gt;Python面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关键在于了解Python的语言特性，结合具体的例子来理解P
      
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="python面试题" scheme="http://yoursite.com/tags/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo从0到1个性化博客搭之环境集成</title>
    <link href="http://yoursite.com/2017/12/22/hexo%E4%BB%8E0%E5%88%B01%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2017/12/22/hexo从0到1个性化博客搭建之环境集成/</id>
    <published>2017-12-22T03:13:46.000Z</published>
    <updated>2018-01-22T06:49:24.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>入行有三年了，一直想拥有属于自己的博客，但我这种懒癌患者知道今天才下手。亲手配置上自己的域名，域名前绿色的小锁；高度定制的前端页面；并且我们不用担心项目的部署问题、前端静态页面的生成问题；最重要的是所有的配置需要免费（大声跟我念 <strong>qiong</strong>）。<br>网络上关于博客搭建的教程一大堆，在此仅作为我自己搭建博客的一个记录及踩过的坑；不尽详尽。ok，废话不多说，here we go。<br>现有如下的方案</p><ul><li><strong>Node.js</strong> (静态HTML页面生成的底层支持)</li><li><strong>Git</strong> (版本管理，博客项目也需要部署到GithubPage上)</li><li><strong> GithubPage</strong> (博客部署，Github免费提供1G的存储空间)</li><li><strong>Hexo</strong> (快速、简洁、高效的博客框架，为Github开源框架)</li><li><strong>Hexo-theme-next</strong> (博客主题插件，为Github上特别流行的开源框架)</li><li><strong>阿里云域名服务</strong> (添加自己的域名)</li><li><strong>Cloudflare CDN分发服务</strong> (让自己的域名支持https)</li><li><strong>Hexo所支持的三方插件服务</strong> (集成站内的全文检索等功能)</li><li><strong>免费的图床</strong> (如7牛)</li><li><strong>DaoVoice</strong> (支持站内时时聊天)<br>此外，只要你会<strong>markdown</strong>，就可以打造属于自己的个性化的博客站点。以上所有版本在此不再一一列举，保持最新版本即可。</li></ul></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>安装<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a><br><img src="https://t1.aixinxi.net/o_1c1ugl7i54uvf0fkvra2l11jba.png-w.jpg" alt=""><br>点击下载安装即可(根据自己不同的操作系统选择)。</li></ul><hr><ul><li>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a><br><img src="https://t1.aixinxi.net/o_1c1uh6db42ou10gs1cpnbnm1fg7a.png-w.jpg" alt=""><br>选择合适的操作系统。</li></ul><hr><ul><li>配置GithubPage<br>登陆自己的Github账户，创建仓库。<br><img src="https://t1.aixinxi.net/o_1c1uk568c1huh10b81op4183n1m3ea.png-w.jpg" alt=""><br>其中红线部分换成你自己的Github名，此格式为固定格式不容许更改。在自己的桌面将项目clone下来，此时应该一个文件也没有(如果创建了README.md文件，hexo在执行hexo g 的时候会将此文件也生成为静态的html文件)。此时在本地创建两个分支master为默认的主分支，(部署我们的生成的静态文件使用)，创建一个分支列如hexo用来存放我们的hexo的项目。创建好分支之后与远程仓库进行关联push上去。</li></ul><hr><ul><li>安装<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a><br><img src="https://t1.aixinxi.net/o_1c1uhgdt91ts7apf1nnk1foed37a.png-w.jpg" alt=""></li></ul><p>打开终端执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>cd 到刚才的从github clone下来的文件夹下将git checkout 到hexo分支下，然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>然后你会看到类似这样的文件内容<br><img src="https://t1.aixinxi.net/o_1c1uhrp9i1dmev3g5e7crdioua.png-w.jpg" alt=""><br>此时继续在终端执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>不出什么差错的话就可以在本地的4000端口上看到默认的博客站点，control+c可以停掉站点<br>默认的站点中会有一篇Hello world的文章。<br>可以先介绍一下部署的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p><p>执行此条命令之后，hexo会自动的将生成的静态html文件部署到你github项目的master分支上去；也就是会在.deploy文件中生成需要部署的静态html文件(需要配置_config.yml文件稍后讲解)；也就是说我们今后不用刻意的push项目的master分支；我们的版本控制在hexo分之下即可。我们也不用配置.gitignore文件(保持默认的忽略文件即可)。</p><hr><ul><li>安装hexo-theme-next</li></ul><ol><li><p>cd 到blog文件夹下的themes文件夹下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:iissnan/hexo-theme-next.git</span><br></pre></td></tr></table></figure></li><li><p>或者执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next.git</span><br></pre></td></tr></table></figure></li></ol><p>第一种方式需要在本地git及github上配置SSH KEY，在此不再赘述。<br><img src="https://t1.aixinxi.net/o_1c1uil0ghjts1d7ovd177p78a.png-w.jpg" alt=""><br>clone完毕之后如下图</p><hr><p><img src="https://t1.aixinxi.net/o_1c1ul9kr91ce114i7ku417vcehoa.png-w.jpg" alt=""><br>我们需要在文件夹的目录下显示隐藏文件(因为有坑)；进入themes文件夹下的hexo-theme-next文件夹，将.git隐藏文件删除；如果不删除当hexo项目切换到hexo分支push的时候是不包括hexo-theme-next文件夹下的内容的(它本身也是一个git仓库)。</p><hr><ul><li>购买<a href="https://cn.aliyun.com" target="_blank" rel="noopener">阿里云域名服务</a><br>笔者花了15¥/年购买了自己的域名服务，国际域名的话还是实名认证比较好。<br><img src="https://t1.aixinxi.net/o_1c1umpavt3vv1kfp1u5o549fa.png-w.jpg" alt=""><br>域名的配置稍后展示。</li></ul><hr><ul><li>注册<a href="https://www.cloudflare.com" target="_blank" rel="noopener">Cloudflare</a>做CDN分发，配置SSL<br>可能需要科学上网更快点<br><img src="https://t1.aixinxi.net/o_1c1umvn7nd49tq0119prvcpnca.png-w.jpg" alt=""><br>所需配置稍后讲解。</li></ul><hr><ul><li>注册免费的图床<a href="https://www.qiniu.com" target="_blank" rel="noopener">7牛</a><br><img src="https://t1.aixinxi.net/o_1c1un6df1lu01lkv1kvkpam12npa.png-w.jpg" alt=""><br>Markdown编辑所用。</li></ul><hr><ul><li>注册<a href="https://account.daocloud.io/signin" target="_blank" rel="noopener">DaoVoice</a>站内及时消息<br><img src="https://t1.aixinxi.net/o_1c1unbgru16ek1aetu9g1noe2lba.png-w.jpg" alt=""><br>最好使用github账号登录。</li></ul><hr><p><strong>至此现有的基本准备工作基本完成</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;入行有三年了，一直想拥有属于自己的博客，但我这种懒癌患者知道今天才下手。亲手配置上自己的域名，域名前绿色的小锁；高
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo博客搭建教程" scheme="http://yoursite.com/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
